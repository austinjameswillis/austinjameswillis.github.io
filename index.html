<!DOCTYPE html>
<html>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.0/angular.min.js"></script>
<!-- CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">

<!-- jQuery and JS bundle w/ Popper.js -->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>

<!-- The core Firebase JS SDK is always required and must be listed first -->
<script src="https://www.gstatic.com/firebasejs/8.2.0/firebase-app.js"></script>

<!-- TODO: Add SDKs for Firebase products that you want to use
     https://firebase.google.com/docs/web/setup#available-libraries -->
<script src="https://www.gstatic.com/firebasejs/8.2.0/firebase-analytics.js"></script>

<script>
  // Your web app's Firebase configuration
  // For Firebase JS SDK v7.20.0 and later, measurementId is optional
  var firebaseConfig = {
    apiKey: "AIzaSyCEOXhKNwELzK0G-NHx8RPwx5Bl5dSgLNI",
    authDomain: "star-wars-dice-roller-d5120.firebaseapp.com",
    projectId: "star-wars-dice-roller-d5120",
    storageBucket: "star-wars-dice-roller-d5120.appspot.com",
    messagingSenderId: "969856043023",
    appId: "1:969856043023:web:ef814488c5c7ac47023b7a",
    measurementId: "G-5MSYYY61D1"
  };
  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  firebase.analytics();
</script>

<!-- AngularFire -->
<script src="https://cdn.firebase.com/libs/angularfire/2.3.0/angularfire.min.js"></script>

<script src="https://www.gstatic.com/firebasejs/8.2.0/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.2.0/firebase-database.js"></script>

<script src="dice.js"></script>
<script src="character_import.js"></script>

<body>

<audio id="nextTurnBeep">
  <source src="beep.mp3" type="audio/mpeg">
  Your browser does not support the audio element.
</audio>

<div ng-app="myApp" ng-controller="myCtrl" class="container">

<p>
	<table class="table table-bordered w-auto">
		<tr>
			<td>
				<button ng-click='num_dice.num_ab_dice = num_dice.num_ab_dice + 1; num_dice.$save();'>
					Add
				</button>
			</td>
			<td rowspan=2>
				<img src="./dice_images/green.png">
			</td>
			<td>
				<button ng-click='num_dice.num_prof_dice = num_dice.num_prof_dice + 1; num_dice.$save();'>
					Add
				</button>
			</td>
			<td rowspan=2>
				<img src="./dice_images/yellow.png">
			</td>
			<td>
				<button ng-click='num_dice.num_boost_dice = num_dice.num_boost_dice + 1; num_dice.$save();'>
					Add
				</button>
			</td>
			<td rowspan=2>
				<img src="./dice_images/blue.png">
			</td>
			<td>
				<button ng-click='num_dice.num_force_dice = num_dice.num_force_dice + 1; num_dice.$save();'>
					Add
				</button>
			</td>
			<td rowspan=2>
				<img src="./dice_images/white.png">
			</td>
		</tr>
		<tr>
			<td>
				<button ng-click='num_dice.num_ab_dice = decreaseAboveZero(num_dice.num_ab_dice, 1); num_dice.$save();'>
					Remove
				</button><br>
			</td>
			<td>
				<button ng-click='num_dice.num_prof_dice = decreaseAboveZero(num_dice.num_prof_dice, 1); '>
					Remove
				</button>
			</td>
			<td>
				<button ng-click='num_dice.num_boost_dice = decreaseAboveZero(num_dice.num_boost_dice, 1); num_dice.$save();'>
					Remove
				</button>
			</td>
			<td>
				<button ng-click='num_dice.num_force_dice = decreaseAboveZero(num_dice.num_force_dice, 1); num_dice.$save();'>
					Remove
				</button>
			</td>
		</tr>
		<tr>
			<td>
				<button ng-click='num_dice.num_diff_dice = num_dice.num_diff_dice + 1; num_dice.$save();'>
					Add
				</button>
			</td>
			<td rowspan=2>
				<img src="./dice_images/purple.png">
			</td>
			<td>
				<button ng-click='num_dice.num_chal_dice = num_dice.num_chal_dice + 1; num_dice.$save();'>
					Add
				</button>
			</td>
			<td rowspan=2>
				<img src="./dice_images/red.png">
			</td>
			<td>
				<button ng-click='num_dice.num_setback_dice = num_dice.num_setback_dice + 1; num_dice.$save();'>
					Add
				</button>
			</td>
			<td rowspan=2>
				<img src="./dice_images/black.png">
			</td>
		</tr>
		<tr>
			<td>
				<button ng-click='num_dice.num_diff_dice = decreaseAboveZero(num_dice.num_diff_dice, 1); num_dice.$save();'>
					Remove
				</button><br>
			</td>
			<td>
				<button ng-click='num_dice.num_chal_dice = decreaseAboveZero(num_dice.num_chal_dice, 1); num_dice.$save();'>
					Remove
				</button><br>
			</td>
			<td>
				<button ng-click='num_dice.num_setback_dice = decreaseAboveZero(num_dice.num_setback_dice, 1); num_dice.$save();'>
					Remove
				</button><br>
			</td>
			<td>
				<button ng-click='rollNewDiePool()'>
					Roll Dice
				</button>
			</td>
		</tr>
	</table>
	
	<img ng-repeat='x in [].constructor(num_dice.num_ab_dice) track by $index' src="./dice_images/green.png" width=80>
	<img ng-repeat='x in [].constructor(num_dice.num_prof_dice) track by $index' src="./dice_images/yellow.png" width=80>
	<img ng-repeat='x in [].constructor(num_dice.num_boost_dice) track by $index' src="./dice_images/blue.png" width=80>
	<img ng-repeat='x in [].constructor(num_dice.num_diff_dice) track by $index' src="./dice_images/purple.png" width=80>
	<img ng-repeat='x in [].constructor(num_dice.num_chal_dice) track by $index' src="./dice_images/red.png" width=80>
	<img ng-repeat='x in [].constructor(num_dice.num_setback_dice) track by $index' src="./dice_images/black.png" width=80>
	<img ng-repeat='x in [].constructor(num_dice.num_force_dice) track by $index' src="./dice_images/white.png" width=80><br><br>
	<img ng-repeat='die_image in die_pool.image_urls track by $index' ng-src='{{die_image}}' width=80><br><br>
	<img ng-repeat='x in [].constructor(die_pool.succ) track by $index' src="./dice_images/success.png" width=60>
	<img ng-repeat='x in [].constructor(die_pool.fail) track by $index' src="./dice_images/failure.png" width=60>
	<img ng-repeat='x in [].constructor(die_pool.adv) track by $index' src="./dice_images/advantage.png" width=60>
	<img ng-repeat='x in [].constructor(die_pool.threat) track by $index' src="./dice_images/threat.png" width=60>
	<img ng-repeat='x in [].constructor(die_pool.triumph) track by $index' src="./dice_images/triumph.png" width=60>
	<img ng-repeat='x in [].constructor(die_pool.despair) track by $index' src="./dice_images/despair.png" width=60>
	<img ng-repeat='x in [].constructor(die_pool.light_side_points) track by $index' src="./dice_images/lightside.png" width=60>
	<img ng-repeat='x in [].constructor(die_pool.dark_side_points) track by $index' src="./dice_images/darkside.png" width=60>
	<br>
</p>

<p>
	<table class="table table-borderless table-responsive">
		<td class="align-middle">
			<button ng-click='passOneDay()'>Pass One Day</button>
		</td>
		<td class="align-middle">
			<button ng-click='endEncounter()'>End Encounter</button>
		</td>
		<td class="align-middle">
			<div class="custom-control custom-switch">
			  <input type="checkbox" class="custom-control-input" id="in_combat_switch" ng-model='general_info.in_combat' ng-change='general_info.$save()'>
			  <label class="custom-control-label" for="in_combat_switch">In Combat</label>
			</div>
		</td>
		<td class="align-middle">
			<button ng-click="rollInitiative()">
				Roll Initiative
			</button>
		</td>
		<td class="align-middle">
			<button ng-click="nextTurn()">
				Next Turn
			</button>
		</td class="align-middle">
		<td>
			<img ng-repeat='slot in getInitiativeOrder() track by $index' ng-src='{{slot.image}}' height=50>
		</td>
	</table>
</p>

<p>
	<table class="table">
		<tr>
			<thead>
				<th>Character Taking Action</th>
				<th>Wounds</th>
				<th ng-if='action_taker.char_type != "Minion"'>Strain</th>
				<th ng-if='action_taker.char_type === "Minion"'># in Group</th>
			<thead>
		</tr>
		<td>
			<select ng-model="action_taker" ng-options='character as character.name for character in getPotentialTurnTakers(show_turn_taken_chars)'>
			</select>
			<button ng-click='startOfTurnResets(action_taker)' ng-disabled='!needToStartOfTurnReset(action_taker)' ng-class="{'btn-danger': needToStartOfTurnReset(action_taker)}" class='btn'>
				Start of Turn
			</button>
			<div class="custom-control custom-switch">
				<input type="checkbox" class="custom-control-input" id="show_turn_taken_chars_switch" ng-model='show_turn_taken_chars'>
				<label class="custom-control-label" for="show_turn_taken_chars_switch">Show Characters Who Have Already Gone</label>
			</div>
		</td>
		<td ng-if='action_taker.char_type != "Minion"'>
			{{action_taker.wounds}} / {{action_taker.wound_threshold}}
		</td>
		<td ng-if='action_taker.char_type === "Minion"'>
			{{action_taker.wounds}} / {{getMinionGroupWT(action_taker)}}
		</td>
		<td ng-if='action_taker.char_type != "Minion"'>
			{{action_taker.strain}} / {{action_taker.strain_threshold}}
		</td>
		<td ng-if='action_taker.char_type === "Minion"'>
			<img ng-if='action_taker.ally_or_enemy === "ally"' ng-repeat='x in [].constructor(getNumActiveMinions(action_taker)) track by $index' ng-src='./dice_images/pc.png' height=25>
			<img ng-if='action_taker.ally_or_enemy === "enemy"' ng-repeat='x in [].constructor(getNumActiveMinions(action_taker)) track by $index' ng-src='./dice_images/npc.png' height=25>
			<img ng-repeat='x in [].constructor(action_taker.num_in_group - getNumActiveMinions(action_taker)) track by $index' ng-src='./dice_images/dead.png' height=25>
		</td>
	</table>
</p>

<p>
	<div class='row'>
		<div class='col'>
			<table class='table'>
				<thead>
					<tr>
						<th class='text-center'>
							{{action_tracker.adv_spent}}/{{die_pool.adv}} <img src="./dice_images/advantage.png" width=25>
						</th>
						<th class='text-center'>
							{{action_tracker.triumph_spent}}/{{die_pool.triumph}} <img src="./dice_images/triumph.png" width=25>
						</th>
						<th>
						</th>
					</tr>
				</thead>
				<tbody>
					<tr ng-if='action_tracker.roll_made && general_info.in_combat && action_taker.char_type != "Minion"'>
						<td>
							<button ng-click='healStrain(action_taker, true)' ng-disabled='!canHealStrain(true) || action_taker.strain <= 0' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/advantage.png" width=20>
							</button>
						</td>
						<td>
							<button ng-click='healStrain(action_taker, false)' ng-disabled='!canHealStrain(false) || action_taker.strain <= 0' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/triumph.png" width=20>
							</button>
						</td>
						<td class='align-middle'>
							Heal 1 Strain
						</td>
					</tr>
					<tr ng-if='action_tracker.roll_made && general_info.in_combat'>
						<td>
							<button ng-click='boostNextAlly(action_taker, true)' ng-disabled='!canBoostNextAlly(true)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/advantage.png" width=20>
							</button>
						</td>
						<td>
							<button ng-click='boostNextAlly(action_taker, false)' ng-disabled='!canBoostNextAlly(false)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/triumph.png" width=20>
							</button>
						</td>
						<td>
							Boost Next Ally
						</td>
					</tr>
					<tr ng-repeat='(hit_id, hit_info) in action_tracker.hits_made'>
						<td>
							<button ng-click='critTarget(action_taker, attack_target, attack_weapon, true, hit_id)' ng-disabled='!canCritTarget(attack_weapon, true, hit_info)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(attack_weapon.crit_rating) track by $index' src="./dice_images/advantage.png" width=20>
							</button>
						</td>
						<td>
							<button ng-click='critTarget(action_taker, attack_target, attack_weapon, false, hit_id)' ng-disabled='!canCritTarget(attack_weapon, false, hit_info)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/triumph.png" width=20>
							</button>
						</td>
						<td class='align-middle'>
							Crit {{characters_dict[hit_info.target_id].name}}
						</td>
					</tr>
					<tr ng-repeat='(hit_id, hit_info) in action_tracker.hits_made' ng-if='hit_info.crit_made'>
						<td class='align-middle' colspan=2>
							<button ng-click='applyCritical(characters_dict[hit_info.target_id], hit_info)' ng-disabled='hit_info.crit_applied' class='btn-block pb-1'>
								Apply d100 
								<span ng-if='hit_info.crit_boost > 0'>
									+ {{hit_info.crit_boost}} 
								</span>
								Crit to {{characters_dict[hit_info.target_id].name}}
							</button>
						</td>
					</tr>
					<tr ng-if='action_tracker.roll_made && attack_target.target_type === "character" && general_info.in_combat'>
						<td>
							<button ng-click='setbackTarget(attack_target, true)' ng-disabled='!canSetbackTarget(true)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(2) track by $index' src="./dice_images/advantage.png" width=20>
							</button>
						</td>
						<td>
							<button ng-click='setbackTarget(attack_target, false)' ng-disabled='!canSetbackTarget(false)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/triumph.png" width=20>
							</button>
						</td>
						<td class='align-middle'>
							Setback Target
						</td>
					</tr>
					<tr ng-if='action_tracker.roll_made && general_info.in_combat'>
						<td>
							<button ng-click='boostAlly(any_boost_target, true)' ng-disabled='!canBoostAlly(true)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(2) track by $index' src="./dice_images/advantage.png" width=20>
							</button>
						</td>
						<td>
							<button ng-click='boostAlly(any_boost_target, false)' ng-disabled='!canBoostAlly(false)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/triumph.png" width=20>
							</button>
						</td>
						<td>
							Boost Any Ally
							<select ng-model='any_boost_target' ng-options='character as character.name for character in getActiveAllies(action_taker, true)' >
						</td>
					</tr>
					<tr ng-if='action_tracker.roll_made && general_info.in_combat'>
						<td>
						</td>
						<td>
							<button ng-click='upgradeTargetDiff(attack_target)' ng-disabled='!canUpgradeTargetDiff()' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/triumph.png" width=20>
							</button>
						</td>
						<td>
							Upgrade Target Difficulty
						</td>
					</tr>
					<tr ng-if='action_tracker.roll_made && general_info.in_combat'>
						<td>
						</td>
						<td>
							<button ng-click='upgradeAlly(any_upgrade_target)' ng-disabled='!canUpgradeAlly()' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/triumph.png" width=20>
							</button>
						</td>
						<td>
							Upgrade Any Ally
							<select ng-model='any_upgrade_target' ng-options='character as character.name for character in getActiveAllies(action_taker, true)'>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<div class='col'>
			<table class='table'>
				<thead>
					<th class='text-center'>
						{{action_tracker.threat_spent}}/{{die_pool.threat}} <img src="./dice_images/threat.png" width=25>
					</th>
					<th class='text-center'>
						{{action_tracker.despair_spent}}/{{die_pool.despair}} <img src="./dice_images/despair.png" width=25>
					</th>
					<th>
					</th>
				</thead>
				<tbody>
					<tr ng-if='action_tracker.roll_made && general_info.in_combat'>
						<td>
							<button ng-click='inflictStrain(action_taker, true)' ng-disabled='!canInflictStrain(true)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/threat.png" width=20>
							</button>
						</td>
						<td>
							<button ng-click='inflictStrain(action_taker, false)' ng-disabled='!canInflictStrain(false)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/despair.png" width=20>
							</button>
						</td>
						<td>
							Inflict 1 Strain
						</td>
					</tr>
					<tr ng-if='action_tracker.roll_made && attack_target.target_type === "character" && general_info.in_combat'>
						<td>
							<button ng-click='boostTarget(attack_target, true)' ng-disabled='!canBoostTarget(true)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(2) track by $index' src="./dice_images/threat.png" width=20>
							</button>
						</td>
						<td>
							<button ng-click='boostTarget(attack_target, false)' ng-disabled='!canBoostTarget(false)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/despair.png" width=20>
							</button>
						</td>
						<td>
							Boost Target
						</td>
					</tr>
					<tr ng-if='action_tracker.roll_made && general_info.in_combat'>
						<td>
							<button ng-click='setbackAlly(any_setback_target, true)' ng-disabled='!canSetbackAlly(true)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(2) track by $index' src="./dice_images/threat.png" width=20>
							</button>
						</td>
						<td>
							<button ng-click='setbackAlly(any_setback_target, false)' ng-disabled='!canSetbackAlly(false)' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/despair.png" width=20>
							</button>
						</td>
						<td>
							Setback Any Ally
							<select ng-model='any_setback_target' ng-options='character as character.name for character in getActiveAllies(action_taker, true)'>
						</td>
					</tr>
					<tr ng-if='action_tracker.roll_made && general_info.in_combat'>
						<td>
						</td>
						<td>
							<button ng-click='upgradeAllyDiff(any_diff_upgrade_target)' ng-disabled='!canUpgradeAllyDiff()' class='btn-block pb-1' style="white-space: nowrap;">
								<img ng-repeat='x in [].constructor(1) track by $index' src="./dice_images/despair.png" width=20>
							</button>
						</td>
						<td>
							Upgrade Ally Difficulty
							<select ng-model='any_diff_upgrade_target' ng-options='character as character.name for character in getActiveAllies(action_taker, true)'>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<div class='col' ng-if='action_tracker.force_roll_made && action_taker.force_rating > 0'>
			<table class='table'>
				<thead>
					<th class='text-center'>
						{{force_powers.fp_spent}}/{{getAvailableForcePoints(action_taker)}} 
						<img ng-src='{{getFPImage(action_taker.lightside_user, false)}}' width=25>
						 ({{getNonMatchingForcePoints(action_taker) - force_powers.fp_converted}}
						<img ng-src='{{getFPImage(action_taker.lightside_user, true)}}' width=25>
						 unconverted)
					</th>
				</thead>
				<tbody>
					<td>
						<!-- Basic Force Power Stuff (Converting, etc.) -->
						<div class="container">
							<div class='row'>
								<div class='col'>
									<div class='custom-control custom-switch'>
										<input type="checkbox" class="custom-control-input" id="lightside_switch" ng-model='action_taker.lightside_user'>
										<label class="custom-control-label" for="lightside_switch">Lightside User</label>
									</div>
								</div>
								<div class='col'>
									<button ng-click='convertForcePoint(action_taker)' ng-disabled='getNonMatchingForcePoints(action_taker) - force_powers.fp_converted <= 0' class='py-1'>
										Convert 
										<img ng-src='{{getFPImage(action_taker.lightside_user, true)}}' width=25>
									</button>
								</div>
							</div>
						</div>
						<!-- Enhance Basic -->
						<div ng-if='enhance_power.using_enhance_basic' class='row mt-2'>
							<div class='col'>
								<button ng-click='activateEnhanceBasic(action_taker, true)' ng-disabled='!canSpendFP(action_taker, 1)' class='btn-block'>
									<img ng-src='{{getFPImage(action_taker.lightside_user, false)}}' width=25>
									Add 
									<img ng-src='./dice_images/success.png' width=25>
								</button>
							</div>
							<div class='col'>
								<button ng-click='activateEnhanceBasic(action_taker, false)' ng-disabled='!canSpendFP(action_taker, 1)' class='btn-block'>
									<img ng-src='{{getFPImage(action_taker.lightside_user, false)}}' width=25>
									Add 
									<img ng-src='./dice_images/advantage.png' width=25>
								</button>
							</div>
						</div>
						<div ng-if='enhance_power.using_force_leap' class=''>
							<div class='row mt-2'>
								<!-- TODO: Make horizontal/vertical a select with vertical unlocked if the control node is unlocked -->
								<div class='col'>
									Leap horizontal to any point within short range.
								</div>
							</div>
							<!-- Force Leap Use/Fail Buttons -->
							<div class='row mt-2'>
								<div class='col'>
									<button ng-click='useEnhanceForceLeap(action_taker)' ng-disabled='!enhance_power.enhance_force_leap_activated' class='btn-block'>
										Make Force Leap
									</button>
								</div>
								<div class='col'>
									<button ng-click='failEnhanceForceLeap(action_taker)' class='btn-block'>
										Fail Force Leap
									</button>
								</div>
							</div>
							<div class='row mt-2'>
								<div class='col'>
									<button class='btn-block py-1' ng-click='activateEnhanceForceLeap()' ng-disabled='!canSpendFP(action_taker, 1) || enhance_power.enhance_force_leap_activated'>
										<img ng-src='{{getFPImage(action_taker.lightside_user, false)}}' width=25>
										 Activate Power
									</button>
								</div>
							</div>
						</div>
						<!-- Move Power -->
						<div ng-if='move_power.using_move' class='container'>
							<!-- Move Basic -->
							<div class='row mt-2' ng-if='move_power.using_move_basic'>
								<div class='col'>
									Move object of Silhouette {{move_power.strength}} or less within {{getRangeString(move_power.range)}} somewhere else within {{getRangeString(move_power.range)}}.
								</div>
							</div>
							<!-- Move Hurl -->
							<div class='row mt-2' ng-if='move_power.using_move_hurl'>
								<div class='col'>
									<div>
										Hurl object of silhouette {{move_power.hurl_object_silhouette}} from within {{getRangeString(move_power.range)}} at {{attack_target.name}} (at max range {{getRangeString(move_power.range)}}).
									</div>
									<div>
										Need to:
										<ul>
											<li ng-class="{'text-success': move_power.move_basic_activated}">Activate Power</li>
											<li ng-class="{'text-success': move_power.strength >= move_power.hurl_object_silhouette}">Increase silhouette to {{move_power.hurl_object_silhouette}}+ (currently {{move_power.strength}})</li>
										</ul>
									</div>
								</div>
							</div>
							<div class='row mt-2' ng-if='action_taker.force_powers.move.pull'>
								<div class='col'>
									Force user is able to
									<ul>
										<li ng-if='action_taker.force_powers.move.pull'>
											Pull objects out of secure mountings or out of an opponent's grasp.
										</li>
									</ul>
								</div>
							</div>
							<!-- Move Use/Fail Buttons -->
							<div class='row mt-2'>
								<div class='col'>
									<button ng-click='useMoveBasic(action_taker, attack_target)' ng-disabled='!move_power.move_basic_activated || (move_power.using_move_hurl && move_power.strength < move_power.hurl_object_silhouette)' class='btn-block'>Use Move Power</button>
								</div>
								<div class='col'>
									<button ng-click='failMoveBasic(action_taker, attack_target)' class='btn-block'>Fail Move Power</button>
								</div>
							</div>
							<div class='row mt-2'>
								<div class='col'>
									<button class='btn-block py-1' ng-click='activateMoveBasic()' ng-disabled='!canSpendFP(action_taker, 1) || move_power.move_basic_activated'>
										<img ng-src='{{getFPImage(action_taker.lightside_user, false)}}' width=25>
										 Activate Power
									</button>
								</div>
							</div>
							<div class='row mt-2' ng-if='action_taker.force_powers.move.strength'>
								<div class='col'>
									<button class='btn-block py-1' ng-click='strengthMove(action_taker)', ng-disabled='!canSpendFP(action_taker, 1) || !move_power.move_basic_activated'>
										<img ng-src='{{getFPImage(action_taker.lightside_user, false)}}' width=25>
										Increase Object Silhouette to {{move_power.strength + action_taker.force_powers.move.strength}}
									</button>
								</div>
							</div>
							<div class='row mt-2' ng-if='action_taker.force_powers.move.range'>
								<div class='col'>
									<button class='btn-block py-1' ng-click='rangeMove(action_taker)', ng-disabled='!canSpendFP(action_taker, 1) || !move_power.move_basic_activated || move_power.range + action_taker.force_powers.move.range > 4'>
										<img ng-src='{{getFPImage(action_taker.lightside_user, false)}}' width=25>
										Increase Range to {{getRangeString(move_power.range + action_taker.force_powers.move.range)}}.
									</button>
								</div>
							</div>
						</div>
					</td>
				</tbody>
			</table>
		</div>
	</div>
</p>

<p>
	<div class="row">
		<!-- Character Actions -->
		<div class="col-md-6">
			<div class='container' ng-if='general_info.in_combat'>
				<div class='row'>
					<div class='col text-center bg-light m-1 p-1 rounded'>
						<span>
							{{action_tracker.actions_taken}}/{{action_tracker.actions_available}} Actions
						</span>
					</div>
					<div class='col text-center bg-light m-1 p-1 rounded'>
						{{action_tracker.maneuvers_taken}}/{{action_tracker.maneuvers_available}} Maneuvers
					</div>
				</div>
				<div class='row mt-2'>
					<div class='col'>
						<button ng-click='convertActionToManeuver(action_taker)' ng-disabled='action_tracker.actions_available <= 0 || action_tracker.maneuvers_available >= 2' class='btn-block'>Convert Action to Maneuver</button>
					</div>
					<div class='col'>
						<button ng-click='strainForManeuver(action_taker)' ng-disabled='action_taker.strain > action_taker.strain_threshold - 2 || action_tracker.maneuvers_available >= 2 || action_taker.char_type === "Minion"' class='btn-block'>Strain for Maneuver</button>
					</div>
				</div>
			</div>
			<div class='container mt-3'>
				<div class='row'>
					<div class='col'>
						<h4>General Actions</h4>
					</div>
				</div>
				<div class='row'>
					<div class='col'>
						<span>Take Action: </span>
						<select ng-model="action_take_skill" ng-options="skill_key as info.name for (skill_key, info) in skill_info">
						</select>
					</div>
				</div>
				<div class='row mt-2' ng-if='action_taker.talents["FRENZ"] && (action_take_skill === "BRAWL" || action_take_skill === "MELEE")'>
					<div class='col-4'>
						Frenzied Attack ({{action_taker.talents["FRENZ"]}})
					</div>
					<div class='col'>
						<input type="number" ng-model="$parent.frenzied_attack_upgrades" min=0 max={{action_taker.talents["FRENZ"]}}>
					</div>
				</div>
				<div class='row mt-2'>
					<div class='col'>
						<button ng-click='matchActionDice(action_taker, action_take_skill)' class='btn-block'>Match Dice</button>
					</div>
					<div class='col'>
						<button ng-click='rollNewDiePool()' class='btn-block'>Roll Dice</button>
					</div>
					<div class='col'>
						<button ng-click='takeAction(action_taker, action_take_skill)' ng-disabled='!canTakeAction(action_taker)' class='btn-block'>Take Action</button>
					</div>
				</div>
			</div>
			<div class='container' ng-if='getAlliedOrganicsWithCriticals(action_taker).length > 0'>
				<div class='row mt-2'>
					<div class='col'>
						<h5>Heal Critical</h5>
					</div>
				</div>
				<div class='row mt-2'>
					<div class='col'>
						Heal Critical From: 
						<select ng-model="$parent.crit_heal_target" ng-options='character as character.name for character in getAlliedOrganicsWithCriticals(action_taker)'>
						</select>
					</div>
				</div>
				<div class='row mt-2'>
					<div class='col'>
						Critical: 
						<select ng-model='$parent.crit_to_heal' ng-options='critical as critical.name disable when critical.heal_attempt_made for critical in crit_heal_target.criticals'>
						</select>
						<img ng-if='$parent.crit_to_heal' ng-repeat='x in [].constructor($parent.crit_to_heal.severity) track by $index' src="./dice_images/purple.png" width=20>
					</div>
				</div>
				<div class='row mt-2'>
					<div class='col'>
						<input type="checkbox" ng-model="$parent.equipment_for_crit_heal">
						Have Proper Equipment
					</div>
				</div>
				<div class='row mt-2'>
					<div class='col'>
						<button ng-click='matchCritHealDice(action_taker, crit_heal_target, crit_to_heal, equipment_for_crit_heal)' class='btn-block'>Match Dice</button>
					</div>
					<div class='col'>
						<button ng-click='rollNewDiePool()' class='btn-block'>Roll Dice</button>
					</div>
					<div class='col'>
						<button ng-click='healCritical(action_taker, crit_heal_target, crit_to_heal)' ng-disabled='!canTakeAction(action_taker)' class='btn-block'>
							Heal Critical
						</button>
					</div>
				</div>
			</div>
			<div class='container' ng-if='getAlliedDroidsWithCriticals(action_taker).length > 0'>
				<div class='row mt-2'>
					<div class='col'>
						<h5>Repair Critical From Droid</h5>
					</div>
				</div>
				<div class='row mt-2'>
					<div class='col'>
						Repair Critical From: 
						<select ng-model="$parent.droid_crit_heal_target" ng-options='character as character.name for character in getAlliedDroidsWithCriticals(action_taker)'>
						</select>
					</div>
				</div>
				<div class='row mt-2'>
					<div class='col'>
						Critical: 
						<select ng-model='$parent.droid_crit_to_heal' ng-options='critical as critical.name disable when critical.heal_attempt_made for critical in droid_crit_heal_target.criticals'>
						</select>
						<img ng-if='$parent.droid_crit_to_heal' ng-repeat='x in [].constructor($parent.droid_crit_to_heal.severity) track by $index' src="./dice_images/purple.png" width=20>
					</div>
				</div>
				<div class='row mt-2'>
					<div class='col'>
						<button ng-click='matchDroidCritHealDice(action_taker, droid_crit_heal_target, droid_crit_to_heal)' class='btn-block'>Match Dice</button>
					</div>
					<div class='col'>
						<button ng-click='rollNewDiePool()' class='btn-block'>Roll Dice</button>
					</div>
					<div class='col'>
						<button ng-click='healCritical(action_taker, droid_crit_heal_target, droid_crit_to_heal)' ng-disabled='!canTakeAction(action_taker)' class='btn-block'>
							Repair Critical
						</button>
					</div>
				</div>
			</div>
			<div ng-if='general_info.in_combat' class='container'>
				<div class='row mt-2'>
					<div class='col'>
						<h5>Combat Actions</h5>
					</div>
				</div>
				<div class='row mt-2'>
					<div class='col'>
						<div class="custom-control custom-switch">
							<input type="checkbox" class="custom-control-input" id="non_matching_targets_switch" ng-model='non_scale_matching_targets'>
							<label class="custom-control-label" for="non_matching_targets_switch">Show Non-Scale Matching Targets</label>
						</div>
						<div class="custom-control custom-switch">
							<input type="checkbox" class="custom-control-input" id="chars_in_other_vehicles_switch" ng-model='chars_in_other_vehicles'>
							<label class="custom-control-label" for="chars_in_other_vehicles_switch">Show Characters in Other Vehicles</label>
						</div>
						<div class="custom-control custom-switch">
							<input type="checkbox" class="custom-control-input" id="chars_of_same_type_switch" ng-model='chars_of_same_type'>
							<label class="custom-control-label" for="chars_of_same_type_switch">Show Characters of Same Type (Ally/Adversary)</label>
						</div>
					</div>
				</div>
				<div class='row mt-2'>
					<div class='col-4'>
						Attack
					</div>
					<div class='col'>
						<select ng-model="$parent.attack_target" ng-options='character as character.name for character in getPotentialTargetsToAttack(action_taker, (attack_weapon ? attack_weapon.damage_scale : ""), non_scale_matching_targets, chars_in_other_vehicles, chars_of_same_type)'>
						</select>
					</div>
				</div>
				<div class='row mt-2'>
					<div class='col-4'>
						with
					</div>
					<div class='col'>
						<!-- TODO: Have WeaponEntry's hold onto the actual name string for the weapon, and use that instead -->
						<!-- Disallow Engaged for Gunnery Weapons -->
						<select ng-model="$parent.attack_weapon" ng-options='weapon as weapon.name for weapon in getPotentialWeaponsForAttack(action_taker)'>
						</select>
					</div>
				</div>
				<div class='row mt-2' ng-if='!$parent.attack_weapon.vehicle_weapon'>
					<div class='col-4'>
						at Range
					</div>
					<div class='col'>
						<select ng-model="$parent.target_range">
							<option value="engaged">Engaged</option>
							<option value="short">Short</option>
							<option value="medium">Medium</option>
							<option value="long">Long</option>
							<option value="extreme">Extreme</option>
						</select>
					</div>
				</div>
				<div class='row mt-2' ng-if='$parent.attack_target.target_type === "vehicle"'>
					<div class='col-4'>
						at Defense Zone
					</div>
					<div class='col'>
						<select ng-model="$parent.target_defense_zone">
							<option value="fore">Fore</option>
							<option value="aft">Aft</option>
							<option value="port">Port</option>
							<option value="starboard">Starboard</option>
							<option value="most">Most</option>
							<option value="least">Least</option>
						</select>
					</div>
				</div>
				<div class='row mt-2' ng-if='action_taker.talents["FRENZ"] && ($parent.attack_weapon.skill_key === "BRAWL" || $parent.attack_weapon.skill_key === "MELEE")'>
					<div class='col-4'>
						Frenzied Attack ({{action_taker.talents["FRENZ"]}})
					</div>
					<div class='col'>
						<input type="number" ng-model="$parent.$parent.frenzied_attack_upgrades" min=0 max={{action_taker.talents["FRENZ"]}}>
					</div>
				</div>
				<div class='row mt-2'>
					<div class='col'>
						<button ng-click='matchAttackDice(action_taker, attack_target, attack_weapon, target_range, target_defense_zone)' class='btn-block'>Match Dice</button>
					</div>
					<div class='col'>
						<button ng-click='rollNewDiePool()' class='btn-block'>Roll Dice</button>
					</div>
					<div class='col'>
						<button ng-click='attackTarget(action_taker, attack_target, attack_weapon)' ng-disabled='!canTakeAction(action_taker)' class='btn-block'>Make Attack</button>
					</div>
				</div>
			</div>
			<div ng-if='action_taker.force_rating > 0' class='container mt-3'>
				<div class='row'>
					<div class='col'>
						<h5>Force Powers</h5>
					</div>
				</div>
				<!-- TODO: Disable This once a roll is made -->
				<div class='row'>
					<div class='col'>
						<select ng-model="$parent.selected_force_power" ng-options='power as power.name for power in getPotentialForcePowers(action_taker)'>
						</select>
					</div>
				</div>
			</div>
			<!-- Enhance Force Power -->
			<div ng-if='selected_force_power.name === "Enhance"' class='container mt-2'>
				<div class='row'>
					<div class='col'>
						The base power adds Force Dice to the following skills:
						<ul>
							<li>
								Athletics
							</li>
							<li	ng-if='selected_force_power.coordination'>
								Coordination
							</li>
						</ul>
					</div>
				</div>
				<div ng-if='action_taker.force_powers.enhance.force_leap'>
					<div class='row'>
						<div class='col'>
							<h6>Force Leap</h6>
						</div>
					</div>
					<div class='row mt-2'>
						<div class='col'>
							<button ng-click='matchForceDice(action_taker)' class='btn-block'>Match Dice</button>
						</div>
						<div class='col'>
							<button class='btn-block' ng-click='rollNewDiePool()'>Roll Dice</button>
						</div>
						<div class='col'>
							<button ng-click='forceLeap(action_taker)' ng-disabled='!canTakeAction(action_taker)' class='btn-block'>
								Force Leap
							</button>
						</div>
					</div>
				</div>
			</div>
			<!-- Move Force Power -->
			<div ng-if='selected_force_power.name === "Move"' class='container mt-2'>
				<div class='row'>
					<div class='col'>
						<h6>Move Object</h6>
					</div>
				</div>
				<div class='row'>
					<div class='col'>
						<button ng-click='matchForceDice(action_taker)' class='btn-block'>Match Dice</button>
					</div>
					<div class='col'>
						<button class='btn-block' ng-click='rollNewDiePool()'>Roll Dice</button>
					</div>
					<div class='col'>
						<button ng-click='forceMoveObject(action_taker)' ng-disabled='!canTakeAction(action_taker)' class='btn-block'>
							Move Object
						</button>
					</div>
				</div>
				<div ng-if='action_taker.force_powers.move.hurl && general_info.in_combat'>
					<div class='row mt-2'>
						<div class='col'>
							<h6>Hurl Object (Attack)</h6>
						</div>
					</div>
					<div  class='row mt-2'>
						<div class='col'>
							Hurl object of Silhouette
							<input type="number" ng-model="hurl_object_silhouette" style="width:50px;" min=0 max=10>
							at 
							<select ng-model="$parent.$parent.attack_target" ng-options='character as character.name for character in getPotentialTargetsToAttack(action_taker, "personal", false, false, false)'>
							</select>
						</div>
					</div>
					<div ng-if='action_taker.force_powers.move.pull' class='row mt-2'>
						<div class='col'>
							<ul>
								<li ng-if='action_taker.force_powers.move.pull'>
									Can pull objects out of secure mountings or out of an opponent's grasp.
								</li>
							</ul>
						</div>
					</div>
					<div class='row mt-2'>
						<div class='col'>
							<button class='btn-block' ng-click='matchForceHurl(action_taker, $parent.$parent.attack_target, hurl_object_silhouette)'>
								Match Dice
							</button>
						</div>
						<div class='col'>
							<button class='btn-block' ng-click='rollNewDiePool()'>Roll Dice</button>
						</div>
						<div class='col'>
							<button ng-click='forceMoveHurl(action_taker, $parent.$parent.attack_target, hurl_object_silhouette)' ng-disabled='!canTakeAction(action_taker)' class='btn-block'>
								Hurl Object (Attack)
							</button>
						</div>
					</div>
				</div>
			</div>
			<!-- General Maneuvers -->
			<div>
				<div class='container mt-3'>
					<div class='row'>
						<div class='col'>
							<h5>General Maneuvers</h5>
						</div>
					</div>
				</div>
				<div ng-if='getAlliedOrganics(action_taker).length > 0' class='container' >
					<div class='row'>
						<div class='col'>
							Apply Stimpack to 
							<select ng-model="$parent.stim_pack_target" ng-options='character as character.name for character in getAlliedOrganics($parent.action_taker)'>
							</select>
							<button ng-click='applyStimpack(action_taker, stim_pack_target)' ng-disabled='stim_pack_target.wounds <= 0 || stim_pack_target.stim_packs_used >= 5 || !canTakeManeuver(action_taker)'>
								Apply
							</button>
						</div>
					</div>
				</div>
				<div ng-if='getAlliedDroids(action_taker).length > 0' class='container'>
					<div class='row'>
						<div class='col'>
							Apply Repair Patch to 
							<select ng-model="$parent.repair_patch_target" ng-options='character as character.name for character in getAlliedDroids($parent.action_taker)'>
							</select>
							<button ng-click='applyRepairPatch(action_taker, repair_patch_target)' ng-disabled='repair_patch_target.wounds <= 0 || repair_patch_target.stim_packs_used >= 5 || !canTakeManeuver(action_taker)'>
								Apply
							</button>
						</div>
					</div>
				</div>
			</div>
			<!-- Combat Maneuvers -->
			<div ng-if='general_info.in_combat'>
				<div class='container mt-3'>
					<div class='row'>
						<div class='col'>
							<h5>Combat Maneuvers</h5>
						</div>
					</div>
					<div class='row'>
						<div class='col'>
							<button ng-click='move(action_taker, move_direction, move_towards_target)' ng-disabled='!canTakeManeuver(action_taker)'>
								Move
							</button>
							<select ng-model="move_direction">
								<option value="forward">Forward</option>
								<option value="backward">Backward</option>
								<option value="left">Left</option>
								<option value="right">Right</option>
								<option value="towards">Towards</option>
								<option value="engage">Engage</option>
							</select>
							<select ng-model="$parent.move_towards_target" ng-options='character as character.name for character in getOtherCharacters($parent.action_taker)' ng-if='move_direction === "towards" || move_direction === "engage"'>
							</select>
						</div>
					</div>
					<div class='row mt-2'>
						<div class='col'>
							<button ng-click='aim(action_taker)' ng-disabled='action_taker.aims >= 2 || !canTakeManeuver(action_taker)' class='btn-block'>Aim</button>
						</div>
						<div class='col'>
							<button ng-click='standUp(action_taker)' ng-disabled='!action_taker.prone || !canTakeManeuver(action_taker)' class='btn-block'>Stand Up</button>
						</div>
						<div class='col'>
							<button ng-click='takeCover(action_taker)' ng-disabled='action_taker.cover_bonus > 0 || !canTakeManeuver(action_taker) || action_taker.prone' class='btn-block'>Take Cover</button>
						</div>
					</div>
				</div>
				<div class='container mt-3' ng-if='action_taker.talents["DEFSTA"]'>
					<div class='row'>
						<div class='col'>
							<h6>Defensive Stance ({{action_taker.talents["DEFSTA"]}})</h6>
						</div>
					</div>
					<div class='row'>
						<div class='col-2'>
							<input type="number" ng-model="def_stance_upgrades" min=0 max={{action_taker.talents["DEFSTA"]}}>
						</div>
						<div class='col'>
							<button ng-click='takeDefensiveStance(action_taker, def_stance_upgrades)' ng-disabled='action_tracker.defensive_stance_taken || action_taker.strain + def_stance_upgrades > action_taker.strain_threshold || !canTakeManeuver(action_taker)'>
								Take Defensive Stance
							</button>
						</div>
					</div>
				</div>
			</div>
			<!-- Combat Incidentals -->
			<div ng-if='general_info.in_combat'>
				<div class='container mt-3'>
					<div class='row'>
						<div class='col'>
							<h5>Combat Incidentals</h5>
						</div>
					</div>
					<div class='row'>
						<div class='col'>
							<button ng-click='goProne(action_taker)' ng-disabled='action_taker.prone'>Go Prone</button>
						</div>
					</div>
				</div>
			</div>
			<div class='container mt-3'>
				<div class='row'>
					<div class='col'>
						<h5>Other</h5>
					</div>
				</div>
			</div>
			<div class='container' ng-if='action_taker.species === "ARKANOFF"'>
				<div class='row'>
					<div class='col'>
						<h6>Genetically Engineered</h6>
					</div>
				</div>
				<div class='row'>
					<div class='col'>
						<input type="checkbox" ng-model="$parent.using_genetically_engineered" ng-disabled='action_tracker.genetically_engineered_used || action_taker.strain >= action_taker.strain_threshold'>
						1 Strain for 
						<img src="./dice_images/blue.png" width=25>
						to Brawn/Agility Check
					</div>
				</div>
			</div>
		</div>
		<!-- Logs -->
		<div class="col-md-6">
			<div>
				<input type="text" ng-model="custom_log">
				<button ng-click="addLogEntry(custom_log)">
					Add Custom Log
				</button>
				<button ng-click="clearLogs()">
					Clear Logs
				</button>
				<div class="custom-control custom-switch row">
					<div class='col'>
						<input type="checkbox" class="custom-control-input" id="reverse_logs_switch" ng-model='reverse_logs'>
						<label class="custom-control-label" for="reverse_logs_switch">Reverse Logs</label>
					</div>
					<div class='col'>
						<input type="checkbox" class="custom-control-input" id="hide_dice_logs_switch" ng-model='hide_dice_roll_logs'>
						<label class="custom-control-label" for="hide_dice_logs_switch">Hide Dice Rolls in Logs</label>
					</div>
				</div>
				<div class="overflow-auto" style="max-height: 500px">
					<table class="table table-striped">
						<tbody>
							<tr ng-repeat='log in getLogs(reverse_logs)'>
								<td>
									<div ng-repeat='log_entry in getLogEntries(log, reverse_logs)'>
										<div ng-if='log_entry.text'>
											{{log_entry.text}}
										</div>
										<div ng-if='log_entry.dice_image_urls && !hide_dice_roll_logs'>
											<img ng-repeat='die_image in log_entry.dice_image_urls track by $index' ng-src='{{die_image}}' width=40><br>
											<img ng-repeat='x in [].constructor(log_entry.succ) track by $index' src="./dice_images/success.png" width=30>
											<img ng-repeat='x in [].constructor(log_entry.fail) track by $index' src="./dice_images/failure.png" width=30>
											<img ng-repeat='x in [].constructor(log_entry.adv) track by $index' src="./dice_images/advantage.png" width=30>
											<img ng-repeat='x in [].constructor(log_entry.threat) track by $index' src="./dice_images/threat.png" width=30>
											<img ng-repeat='x in [].constructor(log_entry.triumph) track by $index' src="./dice_images/triumph.png" width=30>
											<img ng-repeat='x in [].constructor(log_entry.despair) track by $index' src="./dice_images/despair.png" width=30>
											<img ng-repeat='x in [].constructor(log_entry.light_side_points) track by $index' src="./dice_images/lightside.png" width=30>
											<img ng-repeat='x in [].constructor(log_entry.dark_side_points) track by $index' src="./dice_images/darkside.png" width=30>
										</div>
									</div>
								</td>
							</tr>
						</tbody>
					</table>
				</div>
			</div>
		</div>
	</div>
</p>


<h3>Characters</h3>
<hr>

<p>
<b>Import Characters:</b>
<input type="file" id="character-file-input" multiple/>
<button ng-click="readCharacterFiles(read_char_copies)">
	Add Character(s)
</button>
Num Copies: <input type="number" ng-model="read_char_copies" min=1>
</p>


<table class="table table-hover">
	<thead>
		<tr>
			<th>Name</th>
			<th>Soak</th>
			<th>Defense <span style="white-space: nowrap;">Melee / Ranged</span></th>
			<th>Wounds</th>
			<th>Strain</th>
			<th>Ally / Enemy</th>
			<th>Initiative Type</th>
			<th>Vehicle</th>
		</tr>
	</thead>
	
	<tbody>		
		<tr ng-repeat="character in getNonMinions()">
			<td>{{character.name}}</td>
			<td>{{character.soak}}</td>
			<td style="white-space: nowrap;">{{character.def_ranged}} / {{character.def_melee}}</td>
			<td ng-class="{'table-danger': character.wounds > character.wound_threshold}" style="white-space: nowrap;">
				<span>
					<button ng-click="character.wounds = character.wounds - 1; characters_array.$save(character)">
						-
					</button>
				</span>
				<span>
					{{character.wounds}} / {{character.wound_threshold}}
				</span>
				<span>
					<button ng-click="character.wounds = character.wounds + 1; characters_array.$save(character)">
						+
					</button>
				</span>
			</td>
			<td ng-class="{'table-warning': character.strain > character.strain_threshold}" style="white-space: nowrap;">
				<span>
					<button ng-click="character.strain = character.strain - 1; characters_array.$save(character)">
						-
					</button>
				</span>
				<span>
					{{character.strain}} / {{character.strain_threshold}}
				</span>
				<span>
					<button ng-click="character.strain = character.strain + 1; characters_array.$save(character);">
						+
					</button>
				</span>
			</td>
			<td>
				<input type="radio" ng-model="character.ally_or_enemy" value="ally" ng-change='characters_array.$save(character)'> Ally<br>
				<input type="radio" ng-model="character.ally_or_enemy" value="enemy" ng-change='characters_array.$save(character)'> Enemy
			</td>
			<td>
				<input type="radio" ng-model="character.initiative_type" value="cool" ng-change='characters_array.$save(character)'> Cool<br>
				<input type="radio" ng-model="character.initiative_type" value="vigilance" ng-change='characters_array.$save(character)'> Vigilance<br>
				<input type="radio" ng-model="character.initiative_type" value="custom" ng-change='characters_array.$save(character)'> Custom<br>
				<input type="radio" ng-model="character.initiative_type" value="none" ng-change='characters_array.$save(character)'> None<br>
				<img ng-repeat='die_image in character.initiative_roll.image_urls track by $index' ng-src='{{die_image}}' height=20><br>
			</td>
			<td>
				<!-- <select ng-model="character.vehicle" ng-options='vehicle.$id as vehicle.name for vehicle in vehicles_array' ng-change='characters_array.$save(character)'>
				<select> -->
				<select ng-model="character.vehicle" ng-options='id as name for (id, name) in getPotentialVehicles()' ng-change='characters_array.$save(character)'>
				<select>
			</td>
			<td>
				<button ng-click="characters_array.$remove(character)">
					Remove Character
				</button>
			</td>
		</tr>
	</tbody>
</table>

<h4>Minion Groups</h4>

<table class="table table-hover">
	<thead>
		<tr>
			<th>Name</th>
			<th>Soak</th>
			<th>Defense <span style="white-space: nowrap;">Melee / Ranged</span></th>
			<th>Wounds</th>
			<th style="white-space: nowrap;"># In Group</th>
			<th>Ally / Enemy</th>
			<th>Initiative Type</th>
			<th>Vehicle</th>
		</tr>
	</thead>
	
	<tbody>		
		<tr ng-repeat="character in getMinions()">
			<td>{{character.name}}</td>
			<td>{{character.soak}}</td>
			<td style="white-space: nowrap;">{{character.def_ranged}} / {{character.def_melee}}</td>
			<td ng-class="{'table-danger': character.wounds > getMinionGroupWT(character)}" style="white-space: nowrap;">
				<span>
					<button ng-click="character.wounds = character.wounds - 1; characters_array.$save(character)">
						-
					</button>
				</span>
				<span>
					{{character.wounds}} / {{getMinionGroupWT(character)}}
				</span>
				<span>
					<button ng-click="character.wounds = character.wounds + 1; characters_array.$save(character)">
						+
					</button>
				</span>
			</td>
			<td ng-class="{'table-warning': character.strain > character.strain_threshold}" >
				<div clas='container'>
					<div class='row' style="white-space: nowrap;">
						<div class='col' style="text-align: center;">
							<span style="white-space: nowrap;">
								<button ng-click="character.num_in_group = character.num_in_group - 1; characters_array.$save(character)" style="width: 40px">
									-
								</button>
								<button ng-click="character.num_in_group = character.num_in_group + 1; characters_array.$save(character);" style="width: 40px">
									+
								</button>
							</span>
						</div>
					</div>
					<div class='row'>
						<div class='col'>
							<img ng-if='character.ally_or_enemy === "ally"' ng-repeat='x in [].constructor(getNumActiveMinions(character)) track by $index' ng-src='./dice_images/pc.png' height=25>
							<img ng-if='character.ally_or_enemy === "enemy"' ng-repeat='x in [].constructor(getNumActiveMinions(character)) track by $index' ng-src='./dice_images/npc.png' height=25>
							<img ng-repeat='x in [].constructor(character.num_in_group - getNumActiveMinions(character)) track by $index' ng-src='./dice_images/dead.png' height=25>
						</div>
					</div>
				</div>
			</td>
			<td>
				<input type="radio" ng-model="character.ally_or_enemy" value="ally" ng-change='characters_array.$save(character)'> Ally<br>
				<input type="radio" ng-model="character.ally_or_enemy" value="enemy" ng-change='characters_array.$save(character)'> Enemy
			</td>
			<td>
				<input type="radio" ng-model="character.initiative_type" value="cool" ng-change='characters_array.$save(character)'> Cool<br>
				<input type="radio" ng-model="character.initiative_type" value="vigilance" ng-change='characters_array.$save(character)'> Vigilance<br>
				<input type="radio" ng-model="character.initiative_type" value="custom" ng-change='characters_array.$save(character)'> Custom<br>
				<input type="radio" ng-model="character.initiative_type" value="none" ng-change='characters_array.$save(character)'> None<br>
				<img ng-repeat='die_image in character.initiative_roll.image_urls track by $index' ng-src='{{die_image}}' height=20><br>
			</td>
			<td>
				<!-- <select ng-model="character.vehicle" ng-options='vehicle.$id as vehicle.name for vehicle in vehicles_array' ng-change='characters_array.$save(character)'>
				<select> -->
				<select ng-model="character.vehicle" ng-options='id as name for (id, name) in getPotentialVehicles()' ng-change='characters_array.$save(character)'>
				<select>
			</td>
			<td>
				<button ng-click="characters_array.$remove(character)">
					Remove Character
				</button>
			</td>
		</tr>
	</tbody>
</table>


<h3>Vehicles</h3>
<hr>

<p>
	<select ng-model="vehicle_info_to_copy">
		<option ng-repeat="(key, vehicle_info) in vehicle_info" value="{{key}}">{{vehicle_info.name}}</option>
	</select>
	<button ng-click="copyVehicleFromInfo(vehicle_info_to_copy, vehicle_info_copies)">
		Add Copies
	</button>
	Num Copies: <input type="number" ng-model="vehicle_info_copies" min=1>
	<br>
	<input type="file" id="custom-vehicle-file-input"/>
	<button ng-click="readCustomVehicle()">
		Read Custom Vehicle
	</button>
</p>

<p>
	<table class="table table-hover">
		<thead>
			<tr>
				<th>Name</th>
				<th>Model</th>
				<th>Silhouette</th>
				<th>Speed</th>
				<th>Handling</th>
				<th>Armor</th>
				<th>
					Defense<br>
					<span style="white-space: nowrap;">F / P / S / A</span>
				</th>
				<th>Hull Trauma</th>
				<th>System Strain</th>
				<th>Weapons</th>
			</tr>
		</thead>
		
		<tbody>		
			<tr ng-repeat="vehicle in vehicles_array">
				<td style="white-space: nowrap;">{{vehicle.name}}</td>
				<td style="white-space: nowrap;">{{vehicle.model}}</td>
				<td>{{vehicle.silhouette}}</td>
				<td>{{vehicle.speed}}</td>
				<td>{{vehicle.handling}}</td>
				<td>{{vehicle.armor}}</td>
				<td style="white-space: nowrap;">
					{{vehicle.def_fore}} / {{vehicle.def_port}} / {{vehicle.def_starboard}} / {{vehicle.def_aft}}
				</td>
				<td ng-class="{'table-danger': vehicle.hull_trauma > vehicle.hull_trauma_threshold}" style="white-space: nowrap;">
					<span>
						<button ng-click="vehicle.hull_trauma = vehicle.hull_trauma - 1; vehicles_array.$save(vehicle);">
							-
						</button>
					</span>
					<span>
						{{vehicle.hull_trauma}} / {{vehicle.hull_trauma_threshold}}
					</span>
					<span>
						<button ng-click="vehicle.hull_trauma = vehicle.hull_trauma + 1; vehicles_array.$save(vehicle);">
							+
						</button>
					</span>
				</td>
				<td ng-class="{'table-warning': vehicle.system_strain > vehicle.system_strain_threshold}" style="white-space: nowrap;">
					<span>
						<button ng-click="vehicle.system_strain = vehicle.system_strain - 1; vehicles_array.$save(vehicle);">
							-
						</button>
					</span>
					<span>
						{{vehicle.system_strain}} / {{vehicle.system_strain_threshold}}
					</span>
					<span>
						<button ng-click="vehicle.system_strain = vehicle.system_strain + 1; vehicles_array.$save(vehicle);">
							+
						</button>
					</span>
				</td>
				<!-- TODO: Get rid of this? -->
				<td>
					<div ng-repeat="weapon in vehicle.weapons" style="white-space: nowrap;">
						{{weapon.name}}
					</div>
				</td>
				<td>
					<button ng-click="vehicles_array.$remove(vehicle)">
						Remove Vehicle
					</button>
				</td>
			</tr>
	</tbody>
	</table>
</p>


<h3>Item Buying/Selling</h3>
<hr>

<p>
	<table class="table table-dark w-auto">
		<tr>
			<th scope="col">Name:</th>
			<td>
				<input type="text" ng-model="new_item_name">
			</td>
		</tr>
		<tr>
			<th>Rarity:</th>
			<td>
				<input type="number" ng-model="new_item_rarity">
			</td>
		</tr>
		<tr>
			<th>Price:</th>
			<td>
				<input type="number" ng-model="new_item_price">
			</td>
		</tr>
	</table>
	<button ng-click="addNewItem(new_item_name, new_item_price, new_item_rarity)">
		Add New Item
	</button>
</p>

<p>
	<button ng-click="makePurchases(buyer, purchase_skill, rarity_mod)">
		Make Purchases
	</button>
	Buyer:
	<select ng-model="buyer" ng-options='character as character.name for character in characters_array'>
	</select>
	Skill:
	<select ng-model="purchase_skill">
		<option ng-repeat="skill in ['NEG', 'SW']" value="{{skill}}">{{skill_info[skill].name}}</option>
	</select>
	Rarity Modifier:
	<input type="number" ng-model="rarity_mod" min="-2" max="4">

	<table class="table">
		<thead>
			<tr>
				<th>Name</th>
				<th>Price</th>
				<th>Rarity</th>
				<th>Buy / Sell</th>
				<th>Dice Roll</th>
				<th>Result</th>
				<th></th>
			</tr>
		</thead>
		<tr ng-repeat="item in item_entries">
			<td>
				{{item.name}}
			</td>
			<td>
				{{item.price}}
			</td>
			<td>
				{{item.rarity}}
			</td>
			<td>
				<input type="radio" ng-model="item.buy_sell" value="buy"> Buy<br>
				<input type="radio" ng-model="item.buy_sell" value="sell"> Sell<br>		
			</td>
			<td>
				<img ng-repeat='die_image in item.die_pool.image_urls track by $index' ng-src='{{die_image}}' height=25><br>
				<img ng-repeat='x in [].constructor(item.die_pool.succ) track by $index' src="./dice_images/success.png" height=25>
				<img ng-repeat='x in [].constructor(item.die_pool.fail) track by $index' src="./dice_images/failure.png" height=25>
				<img ng-repeat='x in [].constructor(item.die_pool.adv) track by $index' src="./dice_images/advantage.png" height=25>
				<img ng-repeat='x in [].constructor(item.die_pool.threat) track by $index' src="./dice_images/threat.png" height=25>
				<img ng-repeat='x in [].constructor(item.die_pool.triumph) track by $index' src="./dice_images/triumph.png" height=25>
				<img ng-repeat='x in [].constructor(item.die_pool.despair) track by $index' src="./dice_images/despair.png" height=25>
			</td>
			<td>
				<div ng-if="item.roll_made">
					<div ng-if="item.die_pool.succ <= 0">No transaction.</div>
					<div ng-if="item.die_pool.succ > 0 && item.buy_sell == 'buy'">
						Buy {{item.die_pool.succ}} at {{100 - (5 * (item.die_pool.adv - item.die_pool.threat))}}%.
					</div>
					<div ng-if="item.die_pool.succ > 0 && item.buy_sell == 'sell'">
						Sell {{1 + item.die_pool.adv}} at {{getSellPercentage(item.die_pool.succ, item.die_pool.threat)}}%.
					</div>
				</div>
			</td>
			<td>
				<button ng-click="item_entries.$remove(item)">
					Remove Item
				</button>
			</td>
		</tr>
	</table>
</p>

<h3>Admin Stuff</h3>
<hr>

<p>
<button ng-click="readSkillData()">
	Update Skill Data
</button>
<input type="file" id="skill-data-input" />
<br>

<button ng-click="readWeaponData()">
	Update Weapon Data
</button>
<input type="file" id="weapon-data-input" />
<br>

<button ng-click="readVehicleData()">
	Update Vehicle Data
</button>
<input type="file" id="vehicle-info-file-input" multiple/>
</p>

{{debug}}

</div>

<script>

adv_img = "<img src='./dice_images/advantage.png' width=20>"
threat_img = "<img src='./dice_images/threat.png' width=20>"

var app = angular.module('myApp', ["firebase"]);
app.controller('myCtrl', function($scope, $firebaseObject, $firebaseArray) {

	$scope.always_true = true;

	$scope.decreaseAboveZero = function(value, decrement) {
		return Math.max(0, value - decrement);
	}
	
	class ItemEntry {
		constructor(name, price, rarity) {
			this.name = name;
			this.price = price;
			this.rarity = rarity;
			
			this.buy_sell = "buy";
			this.roll_made = false;
			
			this.die_pool = new DicePool(0, 0, 0, 0, 0, 0, 0);
		}
	}
	
	class WeaponEntry {
		constructor(name, skill_key) {
			this.name = name;
			// TODO: Have a key for each weapon. Useful for weapons with special effects like the bolas
			this.skill_key = skill_key;
			
			
			this.damage = 0;
			this.damage_add = 0;
			this.crit = 0;
			
			// TODO: Migrate this to being in a qualities dict rather than seperate fields
			this.pierce = 0;
			this.breach = 0;
			
			this.setback_adds = 0;
			
			this.damage_scale = 'personal';
			this.vehicle_weapon = false;
		}
	}
	
	class ArmorEntry {
		constructor(cortosis) {
			this.cortosis = false;
		}
	}
	
	class InitiativeSlot {
		constructor(succ, adv) {
			this.succ = succ;
			this.adv = adv;
		}
	}
	
	class AllySlot extends InitiativeSlot {
		constructor(succ, adv) {
			super(succ, adv);
			this.image = "./dice_images/pc.png";
			this.type = 'ally';
		}
	}
	
	class EnemySlot extends InitiativeSlot {
		constructor(succ, adv) {
			super(succ, adv);
			this.image = "./dice_images/npc.png";
			this.type = 'enemy';
		}
	}
	
	class EndOfRoundSlot extends InitiativeSlot {
		constructor() {
			super(-1, 0);
			this.image = "./dice_images/repeat.png";
			this.type = 'end_of_round';
		}
	}
	
	$scope.rollNewDiePool = function() {
		let die_pool = new DicePool(
			$scope.num_dice.num_ab_dice,
			$scope.num_dice.num_prof_dice,
			$scope.num_dice.num_boost_dice,
			$scope.num_dice.num_diff_dice,
			$scope.num_dice.num_chal_dice,
			$scope.num_dice.num_setback_dice,
			$scope.num_dice.num_force_dice);
		die_pool.roll();
		$scope.dice_roller.die_pool = die_pool;
		$scope.dice_roller.$save();
		
		$scope.action_tracker.roll_made = true;
		$scope.action_tracker.$save();
		
		$scope.addRollLogEntry(die_pool);
	}
	
	$scope.addSuccToResults = function(num_succ) {
		let pos_succ = $scope.die_pool.succ + num_succ - $scope.die_pool.fail;
		if (pos_succ >= 0) {
			$scope.die_pool.succ = pos_succ;
			$scope.die_pool.fail = 0;
		} else {
			$scope.die_pool.fail -= num_succ;
		}
	}
	
	$scope.addAdvToResults = function(num_adv) {
		let pos_adv = $scope.die_pool.adv + num_adv - $scope.die_pool.threat;
		if (pos_adv >= 0) {
			$scope.die_pool.adv = pos_adv;
			$scope.die_pool.threat = 0;
		} else {
			$scope.die_pool.threat -= num_adv;
		}
	}
	
	$scope.getPotentialTurnTakers = function(show_turn_taken_chars) {
		if ($scope.init_order_array.length <= 0) {
			return [];
		}
		let taker_type = $scope.init_order_array[$scope.initSyncObject.initiative_turn].type;
		let options = [];
		for (var i = 0; i < $scope.characters_array.length; i++) {
			let potential_taker = $scope.characters_array[i];
			// TODO: Put $scope.general_info.in_combat in a parent if
			if ($scope.general_info.in_combat && potential_taker.ally_or_enemy != taker_type) {
				continue;
			}
			if ($scope.general_info.in_combat && !show_turn_taken_chars && potential_taker.turn_taken) {
				continue;
			}
			if ($scope.general_info.in_combat && potential_taker.initiative_type === 'none') {
				continue;
			}
			// TODO: Refacotr with getPotentialTargetsToAttack
			if (potential_taker.char_type === 'Minion') {
				if (potential_taker.wounds > $scope.getMinionGroupWT(potential_taker)) {
					continue;
				}
			} else {
				if (potential_taker.wounds > potential_taker.wound_threshold || potential_taker.strain > potential_taker.strain_threshold) {
					continue;
				}
			}
			options.push(potential_taker);
		}
		return options;
	}
	
	$scope.getOtherCharacters = function(character) {
		if (!character) {
			return [];
		}
		let other_characters = [];
		for (let i = 0; i < $scope.characters_array.length; i++) {
			let maybe_other_char = $scope.characters_array[i];
			if (maybe_other_char != character) {
				other_characters.push(maybe_other_char);
			}
		}
		return other_characters;
	}
	
	$scope.getNonMinions = function() {
		let potential_chars = [];
		for (let i = 0; i < $scope.characters_array.length; i++) {
			let maybe_char = $scope.characters_array[i];
			if (maybe_char.char_type != 'Minion') {
				potential_chars.push(maybe_char);
			}
		}
		return potential_chars;
	}
	
	$scope.getMinions = function() {
		let potential_chars = [];
		for (let i = 0; i < $scope.characters_array.length; i++) {
			let maybe_char = $scope.characters_array[i];
			if (maybe_char.char_type === 'Minion') {
				potential_chars.push(maybe_char);
			}
		}
		return potential_chars;
	}
	
	$scope.getAllies = function(character, include_self) {
		if (!character) {
			return [];
		}
		var potential_allies = [];
		for (var i = 0; i < $scope.characters_array.length; i++) {
			let maybe_ally = $scope.characters_array[i];
			if (maybe_ally === character && !include_self) {
				continue;
			}
			if (maybe_ally.ally_or_enemy != character.ally_or_enemy) {
				continue;
			}
			potential_allies.push(maybe_ally);
		}
		return potential_allies;
	}
	
	$scope.getActiveAllies = function(character, include_self) {
		let all_allies = $scope.getAllies(character, include_self);
		let all_active_allies = [];
		for (let i = 0; i < all_allies.length; i++) {
			let potential_ally = all_allies[i];
			if (potential_ally.initiative_type === 'none') {
				continue;
			}
			// TODO: Refactor with getPotentialTargetsToAttack
			if (potential_ally.char_type === 'Minion') {
				if (potential_ally.wounds > $scope.getMinionGroupWT(potential_ally)) {
					continue;
				}
			} else {
				if (potential_ally.wounds > potential_ally.wound_threshold || potential_ally.strain > potential_ally.strain_threshold) {
					continue;
				}
			}
			all_active_allies.push(potential_ally);
		}
		return all_active_allies;
	}
	
	$scope.getAlliedOrganics = function(character) {
		let all_allies = $scope.getAllies(character, true);
		let all_organic_allies = [];
		for (let i = 0; i < all_allies.length; i++) {
			if (all_allies[i].species === 'DROID') {
				continue;
			}
			all_organic_allies.push(all_allies[i]);
		}
		return all_organic_allies;
	}
	
	$scope.getAlliedOrganicsWithCriticals = function(character) {
		let potential_allies = $scope.getAlliedOrganics(character);
		let allies_with_criticals = [];
		for (let i = 0; i < potential_allies.length; i++) {
			if (potential_allies[i].criticals) {
				allies_with_criticals.push(potential_allies[i]);
			}
		}
		return allies_with_criticals;
	}
	
	$scope.getAlliedDroidsWithCriticals = function(character) {
		let potential_allies = $scope.getAlliedDroids(character);
		let allies_with_criticals = [];
		for (let i = 0; i < potential_allies.length; i++) {
			if (potential_allies[i].criticals) {
				allies_with_criticals.push(potential_allies[i]);
			}
		}
		return allies_with_criticals;
	}
	
	$scope.getAlliedDroids = function(character) {
		let all_allies = $scope.getAllies(character, true);
		let all_droid_allies = [];
		for (let i = 0; i < all_allies.length; i++) {
			if (all_allies[i].species != 'DROID') {
				continue;
			}
			all_droid_allies.push(all_allies[i]);
		}
		return all_droid_allies;
	}
	
	//// Positive Dice Side Effects
	$scope.hasRequiredAdvantageOrTriumph = function(num_adv_req, using_adv) {
		if (using_adv) {
			return $scope.die_pool.adv - $scope.action_tracker.adv_spent >= num_adv_req
		}
		// TODO: Make Triumph variable instead of always 1 (can use num_adv_req)
		return $scope.die_pool.triumph - $scope.action_tracker.triumph_spent >= 1;
	}
	
	$scope.spendRequiredAdvantageOrTriumph = function(num_adv_req, using_adv) {
		let spent_log = num_adv_req + ' Advantage';
		if (using_adv) {
			$scope.action_tracker.adv_spent = $scope.action_tracker.adv_spent + num_adv_req;
		} else {
			// TODO: Make Triumph variable instead of always 1 (can use num_adv_req)
			$scope.action_tracker.triumph_spent = $scope.action_tracker.triumph_spent + 1;
			spent_log = '1 Triumph';
		}
		$scope.action_tracker.$save();
		return spent_log;
	}
	
	// Heal 1 Strain w/ 1 Adv (or 1 Triumph) (Repeatable)
	$scope.canHealStrain = function(using_adv) {
		return $scope.hasRequiredAdvantageOrTriumph(1, using_adv);
	}
	
	$scope.healStrain = function(action_taker, using_adv) {	
		let spent_log = $scope.spendRequiredAdvantageOrTriumph(1, using_adv);
		
		action_taker.strain = action_taker.strain - 1;
		$scope.characters_array.$save(action_taker);
		
		// TODO: Make verbose?
		$scope.addLogEntry(`${spent_log} spent to heal 1 strain (${action_taker.strain}/${action_taker.strain_threshold}).`);
	}
	
	// Boost Next Ally w/ 1 Adv
	$scope.canBoostNextAlly = function(using_adv) {
		return !$scope.action_tracker.boost_next_used && $scope.hasRequiredAdvantageOrTriumph(1, using_adv);
	}
	
	// TODO: This one, confirm previous, create boost_next_used
	$scope.boostNextAlly = function(action_taker, using_adv) {
		$scope.action_tracker.boost_next_used = true;
		$scope.action_tracker.boost_any[action_taker.ally_or_enemy] = $scope.action_tracker.boost_any[action_taker.ally_or_enemy] + 1;
		let spent_log = $scope.spendRequiredAdvantageOrTriumph(1, using_adv);
		
		// TODO: Make Verbose?
		$scope.addLogEntry(`${spent_log} spent to boost next ally.`);
	}
	
	// Crit Target w/ X Addv (or 1 Triumph) (Repeatable; Each Repeat adds +10 to roll)
	$scope.canCritTarget = function(weapon, using_adv, hit_info) {
		if (!weapon) {
			return false;
		}
		if (hit_info.crit_applied) {
			return false;
		}
		let crit_rating = weapon.crit_rating;
		return $scope.hasRequiredAdvantageOrTriumph(crit_rating, using_adv);
	}
	
	$scope.critTarget = function(action_taker, target, weapon, using_adv, hit_id) {
		let crit_rating = weapon.crit_rating;
		let spent_log = $scope.spendRequiredAdvantageOrTriumph(crit_rating, using_adv);
		
		let hit_info = $scope.action_tracker.hits_made[hit_id];
		
		if (target.char_type === 'Minion') {
			target.wounds += target.wound_threshold;
			hit_info.crit_applied = true;
			$scope.addLogEntry(`1 minion in ${target.name} dies. (${$scope.getNumActiveMinions(target)}/${target.num_in_group} minions remaining) (${target.wounds}/${$scope.getMinionGroupWT(target)} wounds)`);
			if ($scope.getNumActiveMinions(target) <= 0) {
				$scope.addLogEntry(`Minion group ${target.name} has been destroyed.`);
			}
			$scope.characters_array.$save(target);
		} else {
			if (hit_info.crit_made) {
				hit_info.crit_boost += 10;
				$scope.addLogEntry(`${spent_log} spent to boost ${target.name}'s crit by 10.`);
			} else {
				hit_info.crit_made = true;
				crit_boost = 0;
				if (target.criticals) {
					crit_boost += target.criticals.length * 10;
				}
				if (action_taker.talents['LETHALBL']) {
					crit_boost += action_taker.talents['LETHALBL'] * 10;
				}
				if (target.talents['DURA']) {
					crit_boost -= target.talents['DURA'] * 10;
				}
				hit_info.crit_boost = crit_boost;
				$scope.addLogEntry(`${spent_log} spent to crit ${target.name}.`);
			}
		}

		$scope.action_tracker.$save();
	}
	
	$scope.applyCritical = function(target, hit_info) {
		let crit_roll = Math.floor(Math.random() * 100) + 1; // Random number 1-100
		crit_roll = crit_roll + hit_info.crit_boost;
		if (target.criticals) {
			crit_roll = crit_roll + target.criticals.length * 10;
		}
		let critical = null;
		
		if (crit_roll <= 5) {
			critical = new Critical('Minor Nick', 1);
			critical.description = "The target suffers 1 strain.";
			target.strain = target.strain + 1;
		} else if (crit_roll <= 10) {
			critical = new Critical('Slowed Down', 1);
			critical.description = "The target can only act during the last allied initiative slot on his next turn. <UNIMPLEMENTED>";
		} else if (crit_roll <= 15) {
			critical = new Critical('Sudden Jolt', 1);
			critical.description = "The target drops whatever is in hand. <UNIMPLEMENTED>";
		} else if (crit_roll <= 20) {
			critical = new Critical('Distracted', 1)
			critical.description = "The target cannot perform a free maneuver during his next turn. <UNIMPLEMENTED>";
		} else if (crit_roll <= 25) {
			critical = new Critical('Off-Balance', 1);
			critical.description = "Add [SETBACK] to the target's next skill check.";
			target.temp_setbacks = target.temp_setbacks + 1;
		} else if (crit_roll <= 30) {
			critical = new Critical('Discouraging Wound', 1);
			critical.description = "Flip one light side Destiny Point to a dark side Destiny Point (reverse if NPC). <UNIMPLEMENTED>";
		} else if (crit_roll <= 35) {
			critical = new Critical('Stunned', 1);
			critical.description = "The target is staggered until the end of the next round. <UNIMPLEMENTED>";
		} else if (crit_roll <= 40) {
			critical = new Critical('Stinger', 1);
			critical.description = "Increase difficulty of next check by one. <UNIMPLEMENTED>";
		} else if (crit_roll <= 45) {
			critical = new Critical('Bowled Over', 2);
			critical.description = "The target is knocked prone and suffers 1 strain.";
			target.strain = target.strain + 1;
			target.prone = true;
		} else if (crit_roll <= 50) {
			critical = new Critical('Head Ringer', 2);
			critical.description = "The target increases the difficulty of all Intellect and Cunning checks by one until the end of the encounter. <UNIMPLEMENTED>";
		} else if (crit_roll <= 55) {
			critical = new Critical('Fearsome Wound', 2);
			critical.description = "The target increases the difficulty of all Presence and Willpower checks by one until the end of the encounter. <UNIMPLEMENTED>";
		} else if (crit_roll <= 60) {
			critical = new Critical('Agonizing Wound', 2);
			critical.description = "The target increases the difficulty of all Brawn and Agility checks by one until the end of the encounter. <UNIMPLEMENTED>";
		} else if (crit_roll <= 65) {
			critical = new Critical('Slightly Dazed', 2);
			critical.description = "The target is disoriented until the end of the encounter. <UNIMPLEMENTED>";
		} else if (crit_roll <= 70) {
			critical = new Critical('Scattered Senses', 2);
			critical.description = "The target removes all [BOOST] from skill checks until the end of the encounter. <UNIMPLEMENTED>";
		} else if (crit_roll <= 75) {
			critical = new Critical('Hamstrung', 2);
			critical.description = "The target loses his free maneuver until the end of the encounter. <UNIMPLEMENTED>";
		} else if (crit_roll <= 80) {
			critical = new Critical('Overpowered', 2);
			critical.description = "The target leaves himself open, and the attacker may make immediately attempt another free attack against him, using the exact same pool as the original attack. <UNIMPLEMENTED>";
		} else if (crit_roll <= 85) {
			critical = new Critical('Winded', 2);
			critical.description = "Until the end of the encounter, the target cannot voluntarily suffer strain to activate any abilities or gain additional maneuvers. <UNIMPLEMENTED>";
		} else if (crit_roll <= 90) {
			critical = new Critical('Compromised', 2);
			critical.description = "Increase the difficulty of all skill checks by one until the end of the encounter. <UNIMPLEMENTED>";
		} else if (crit_roll <= 95) {
			critical = new Critical('At the Brink', 3);
			critical.description = "The target suffers 1 strain each time he performs an action. <UNIMPLEMENTED>";
		} else if (crit_roll <= 100) {
			critical = new Critical('Crippled', 3);
			critical.description = "One of the target's limbs (selected by the GM) is crippled until healed or replaced. Increase difficulty of all checks that require use of that limb by one. <UNIMPLEMENTED>";
		} else if (crit_roll <= 105) {
			critical = new Critical('Maimed', 3);
			critical.description = "One of the target's limbs (selected by the GM) is permanently logs. Unless the target has a cybernetic replacement, the target cannot perform actions that would require the use of that limb. All other actions gain [SETBACK]. <UNIMPLEMENTED>";
		} else if (crit_roll <= 110) {
			critical = new Critical('Horrific Injury', 3);
			critical.description = "Roll 1d10 to determine which of the target's characteristics is affected: 1-3 for Brawn, 4-6 for Agility, 7 for Intellect, 8 for Cunning, 9 for Presence, and 10 for Willpower. Until this Critical Injury is healed, treat that characteristic as 1 ponit lower. <UNIMPLEMENTED>";
		} else if (crit_roll <= 115) {
			critical = new Critical('Temporarily Lame', 3);
			critical.description = "Until this Critical Injury is healed, the target cannot perform more than one maneuver during his turn. <UNIMPLEMENTED>";
		} else if (crit_roll <= 120) {
			critical = new Critical('Blinded', 3);
			critical.description = "The target can no longer see. Upgrade the difficulty of all checks twice. Upgrade the difficulty of Perception and Vigilance checks three times. <UNIMPLEMENTED>";
		} else if (crit_roll <= 125) {
			critical = new Critical('Knocked Senseless', 3);
			critical.description = "The target is staggered for the remainder of the encounter. <UNIMPLEMENTED>";
		} else if (crit_roll <= 130) {
			critical = new Critical('Gruesome Injury', 4);
			critical.description = "Roll 1d10 to determine which of the target's characteristics is affected: 1-3 for Brawn, 4-6 for Agility, 7 for Intellect, 8 for Cunning, 9 for Presence, 10 for Willpower. That characteristic is permanently reduced by 1 to a minimum of 1. <UNIMPLEMENTED>";
		} else if (crit_roll <= 140) {
			critical = new Critical('Bleeding Out', 4);
			critical.description = "Every round, the target suffers 1 wound and 1 strain at the beginning of his turn. For every 5 wounds he suffers beyond his wound thershold, he suffers 1 additional Critical Injury. Roll on the chart, suffering the injury (if he suffers this result a second time due to this, roll again). <UNIMPLEMENTED>";
		} else if (crit_roll <= 150) {
			critical = new Critical('The End is Nigh', 4);
			critical.description = "The target will die after the last initiative slot during the next round. <UNIMPLEMENTED>";
		} else {
			critical = new Critical('Dead', 10000000);
			critical.description = "Complete, obliterated death. <UNIMPLEMENTED>";
		}
		
		critical.day_received = $scope.day.$value;
		
		if (target.criticals) {
			target.criticals.push(critical);
		} else {
			target.criticals = [critical];
		}
		
		let log_message = `${crit_roll} rolled. ${target.name} suffers the following critical injury. ` +
			`${critical.name}: ${critical.description}`;
		$scope.addLogEntry(log_message);
		
		// TODO: Investigte this
		$scope.characters_dict[hit_info.target_id] = target;
		$scope.characters_dict.$save();
		
		hit_info.crit_applied = true;
		$scope.action_tracker.$save();
		
		return critical;
	}
	
	// Setback Target w/ 2 Adv (TODO: Or Triumph)
	$scope.canSetbackTarget = function(using_adv) {
		return !$scope.action_tracker.setback_target_used && $scope.hasRequiredAdvantageOrTriumph(2, using_adv);
	}
	
	$scope.setbackTarget = function(target, using_adv) {		
		$scope.action_tracker.setback_target_used = true;
		let spent_log = $scope.spendRequiredAdvantageOrTriumph(2, using_adv);
		
		target.temp_setbacks = target.temp_setbacks + 1;
		$scope.characters_array.$save(target);
		
		// TODO: Make verbose?
		$scope.addLogEntry(`${spent_log} spent to setback ${target.name}.`);
	}
	
	// Boost Any Ally w/ 2 Adv
	$scope.canBoostAlly = function(using_adv) {
		return !$scope.action_tracker.boost_any_used && $scope.hasRequiredAdvantageOrTriumph(2, using_adv);
	}
	
	$scope.boostAlly = function(ally, using_adv) {
		$scope.action_tracker.boost_any_used = true;
		let spent_log = $scope.spendRequiredAdvantageOrTriumph(2, using_adv);
		
		ally.temp_boosts = ally.temp_boosts + 1;
		$scope.characters_array.$save(ally);
		
		// TODO: Make Verbose?
		$scope.addLogEntry(`${spent_log} spent to boost ${ally.name}.`);
	}
	
	// Upgrade Target's Difficulty Triumph
	$scope.canUpgradeTargetDiff = function() {
		return !$scope.action_tracker.upgrade_target_diff_used && $scope.hasRequiredAdvantageOrTriumph(1, false);
	}
	
	$scope.upgradeTargetDiff = function(target) {
		$scope.action_tracker.upgrade_target_diff_used = true;
		$scope.spendRequiredAdvantageOrTriumph(1, false);
		
		target.temp_diff_upgrades += 1;
		$scope.characters_array.$save(target);
		
		$scope.addLogEntry(`1 Triumph spent to upgrade difficulty of ${target.name}\'s next check.`);
	}
	
	// Upgrade Any Ally w/ 1 Triumph
	$scope.canUpgradeAlly = function() {
		return !$scope.action_tracker.upgrade_ally_used && $scope.hasRequiredAdvantageOrTriumph(1, false);
	}
	
	$scope.upgradeAlly = function(ally) {
		$scope.action_tracker.upgrade_ally_used = true;
		$scope.spendRequiredAdvantageOrTriumph(1, false);
		
		ally.temp_upgrades += 1;
		$scope.characters_array.$save(ally);
		
		$scope.addLogEntry(`1 Triumph spent to upgrade ${ally.name}\'s next check.`);
	}
	
	//// Negative Dice Side Effects
	
	$scope.hasRequiredThreatOrDespair = function(num_threat_req, using_threat) {
		if (using_threat) {
			return $scope.die_pool.threat - $scope.action_tracker.threat_spent >= num_threat_req
		}
		// TODO: Make despair variable instead of always 1 (can use num_threat_req(
		return $scope.die_pool.despair - $scope.action_tracker.despair_spent >= 1;
	}
	
	$scope.spendRequiredThreatOrDespair = function(num_threat_req, using_threat) {
		let spent_log = num_threat_req + ' Threat';
		if (using_threat) {
			$scope.action_tracker.threat_spent = $scope.action_tracker.threat_spent + num_threat_req;
		} else {
			$scope.action_tracker.despair_spent = $scope.action_tracker.despair_spent + 1;
			spent_log = '1 Despair';
		}
		$scope.action_tracker.$save();
		return spent_log;
	}
	
	// Inflict 1 Strain w/ 1 Threat or 1 Despair
	$scope.canInflictStrain = function(using_threat) {
		return $scope.hasRequiredThreatOrDespair(1, using_threat);
	}
	
	$scope.inflictStrain = function(action_taker, using_threat) {	
		let spent_log = $scope.spendRequiredThreatOrDespair(1, using_threat);
		
		if (action_taker.char_type === 'Minion') {
			let num_starting_minions = $scope.getNumActiveMinions(action_taker);
			action_taker.wounds += 1;
			
			$scope.addLogEntry(`${spent_log} spent to inflict 1 strain (wound). (${action_taker.wounds}/${$scope.getMinionGroupWT(action_taker)} wounds).`);
			
			let num_new_minions = $scope.getNumActiveMinions(action_taker);
			let num_minions_lost = num_starting_minions - num_new_minions;
			if (num_minions_lost > 0) {
				$scope.addLogEntry(`${character.name} loses ${num_minions_lost} minions. (${$scope.getNumActiveMinions(target)}/${target.num_in_group} minions remaining)`);
				if (new_minions_in_group <= 0) {
					$scope.addLogEntry(`Minion group ${character.name} has been destroyed.`);
				}
			}
		} else {
			action_taker.strain = action_taker.strain + 1;
			// TODO: Make verbose?
			$scope.addLogEntry(`${spent_log} spent to inflict 1 strain (${action_taker.strain}/${action_taker.strain_threshold}).`);
		}
		
		$scope.characters_array.$save(action_taker);
	}
	
	// Boost Target w/ 2 Threat or 1 Despair
	$scope.canBoostTarget = function(using_threat) {
		return !$scope.action_tracker.boost_target_used && $scope.hasRequiredThreatOrDespair(2, using_threat);
	}
	
	$scope.boostTarget = function(target, using_threat) {
		$scope.action_tracker.boost_target_used = true;
		let spent_log = $scope.spendRequiredThreatOrDespair(2, using_threat);
	
		target.temp_boosts = target.temp_boosts + 1;
		$scope.characters_array.$save(target);
		
		
		// TODO: Make Verbose?
		$scope.addLogEntry(`${spent_log} spent to boost ${target.name}.`);
	}
	
	// Setback Any Ally w/ 2 Threat or 1 Despair
	$scope.canSetbackAlly = function(using_threat) {
		return !$scope.action_tracker.setback_any_used && $scope.hasRequiredThreatOrDespair(2, using_threat);
	}
	
	$scope.setbackAlly = function(ally, using_threat) {
		if (!ally) {
			// TODO: Show an error message
			return;
		}
		$scope.action_tracker.setback_any_used = true;
		let spent_log = $scope.spendRequiredThreatOrDespair(2, using_threat);
	
		ally.temp_setbacks = ally.temp_setbacks + 1;
		$scope.characters_array.$save(ally);
		
		// TODO: Make Verbose?
		$scope.addLogEntry(`${spent_log} spent to setback ${ally.name}.`);
	}
	
	// Upgrade Difficulty of Ally's next check w/ 1 Despair
	$scope.canUpgradeAllyDiff = function() {
		return !$scope.action_tracker.upgrade_any_diff_used && $scope.hasRequiredThreatOrDespair(1, false);
	}
	
	$scope.upgradeAllyDiff = function(ally) {
		if (!ally) {
			// TODO: Show an error message
			return;
		}
		$scope.action_tracker.upgrade_any_diff_used = true;
		$scope.spendRequiredThreatOrDespair(1, false);
	
		ally.temp_diff_upgrades++;
		$scope.characters_array.$save(ally);
		
		$scope.addLogEntry(`1 Despair spent to upgrade the difficulty of ${ally.name}\'s next check.`);
	}
	
	$scope.convertActionToManeuver = function(action_taker) {
		$scope.action_tracker.actions_available = $scope.action_tracker.actions_available - 1;
		$scope.action_tracker.maneuvers_available = $scope.action_tracker.maneuvers_available + 1;
		$scope.action_tracker.$save();
		$scope.addLogEntry(`${action_taker.name} converts their action to a maneuver.`);
	}
	
	$scope.strainForManeuver = function(action_taker) {
		action_taker.strain = action_taker.strain + 2;
		$scope.action_tracker.maneuvers_available = $scope.action_tracker.maneuvers_available + 1;
		$scope.characters_array.$save(action_taker);
		$scope.action_tracker.$save();
		$scope.addLogEntry(`${action_taker.name} takes 2 strain for an extra maneuver.`);
	}
	
	$scope.removeAims = function(character) {
		if (character.aims > 0) {
			character.aims = 0;
			$scope.addLogEntry(`${character.name} has lost their aim.`);
			$scope.characters_array.$save(character);
		}
	}
	
	$scope.leaveCover = function(character) {
		if (character.cover_bonus > 0) {
			character.cover_bonus = 0;
			$scope.addLogEntry(`${character.name} leaves cover.`);
			$scope.characters_array.$save(character);
		}
	}
	
	$scope.canTakeAction = function(character) {
		if (!$scope.general_info.in_combat) {
			return true;
		}
	
		if ($scope.action_tracker.actions_taken >= $scope.action_tracker.actions_available) {
			return false;
		}
		// TODO: Account for Staggered
		return true;
	}
	
	$scope.canTakeManeuver = function(character) {
		if (!$scope.general_info.in_combat) {
			return true;
		}
	
		if ($scope.action_tracker.maneuvers_taken >= $scope.action_tracker.maneuvers_available) {
			return false;
		}
		// TODO: Account for Immobilized
		return true;
	}
	
	$scope.incrementActionsTaken = function() {
		if (!$scope.general_info.in_combat) {
			return;
		}
		$scope.action_tracker.actions_taken = $scope.action_tracker.actions_taken + 1;
		$scope.action_tracker.$save();
	}
	
	// Add Force Dice if the Enhance Force Power can be used
	$scope.matchEnhanceDice = function(action_taker, skill_key) {
		let using_enhance = false;
		if (action_taker.force_powers && action_taker.force_powers.enhance && action_taker.force_powers.enhance.unlocked) {
			// TODO: Add other Enhance skills if unlocked
			switch(skill_key) {
				case('ATHL'):
					using_enhance = true;
					break;
				case('COORD'):
					if (action_taker.force_powers.enhance.coordination) {
						using_enhance = true;
					}
					break;
				case('RESIL'):
					if (action_taker.force_powers.enhance.resilience) {
						using_enhance = true;
					}
					break;
				case('BRAWL'):
					if (action_taker.force_powers.enhance.brawl) {
						using_enhance = true;
					}
					break;
				default:
					break;
			}
		}
		
		if (using_enhance) {
			$scope.num_dice.num_force_dice = action_taker.force_rating;
			$scope.action_tracker.force_roll_made = true;
			$scope.enhance_power.using_enhance_basic = true;
		} else {
			$scope.num_dice.num_force_dice = 0;
			$scope.action_tracker.force_roll_made = false;
			$scope.enhance_power.using_enhance_basic = false;
		}
		
		$scope.action_tracker.$save();
	}
	
	$scope.upgradeDice = function(num_upgrades) {
		let num_ab_dice = $scope.num_dice.num_ab_dice;
		let num_prof_dice = $scope.num_dice.num_prof_dice;
		for (let i = 0; i < num_upgrades; i++) {
			if (num_ab_dice > 0) {
				num_ab_dice--;
				num_prof_dice++;
			} else {
				num_ab_dice++;
			}
		}
		$scope.num_dice.num_ab_dice = num_ab_dice;
		$scope.num_dice.num_prof_dice = num_prof_dice;
	}
	
	$scope.upgradeDiffDice = function(num_upgrades) {
		
		let num_diff_dice = $scope.num_dice.num_diff_dice;
		let num_chal_dice = $scope.num_dice.num_chal_dice;
		for (let i = 0; i < num_upgrades; i++) {
			if (num_diff_dice > 0) {
				num_diff_dice--;
				num_chal_dice++;
			} else {
				num_diff_dice++;
			}
		}
		$scope.num_dice.num_diff_dice = num_diff_dice;
		$scope.num_dice.num_chal_dice = num_chal_dice;
	}
	
	$scope.matchCommonDice = function(action_taker, skill_key) {
		let char_key = $scope.skill_info[skill_key].char_key;
	
		var skill_dice_needed = $scope.getSkillDice(action_taker, skill_key);
		$scope.num_dice.num_ab_dice = skill_dice_needed[0];
		$scope.num_dice.num_prof_dice = skill_dice_needed[1];
		
		let num_boost_dice = 0;
		num_boost_dice += action_taker.temp_boosts;
		num_boost_dice += $scope.action_tracker.boost_any[action_taker.ally_or_enemy];
		if ($scope.using_genetically_engineered) {
			if (char_key === 'BR' || char_key === 'AG') {
				num_boost_dice++;
			}
		}		
		
		$scope.num_dice.num_boost_dice = num_boost_dice;
		$scope.num_dice.num_setback_dice = action_taker.temp_setbacks;
		$scope.num_dice.num_force_dice = 0;
		// TODO: Add any setback removal to skill (separate icon/value in dice roller that removes the matching number of setbacks?)
		
		let num_upgrades = action_taker.temp_upgrades;
		if (action_taker.talents["FRENZ"] && $scope.frenzied_attack_upgrades) {
			num_upgrades += $scope.frenzied_attack_upgrades;
		}
		$scope.upgradeDice(num_upgrades);
		
		$scope.matchEnhanceDice(action_taker, skill_key);
	}
	
	$scope.matchActionDice = function(action_taker, skill_key) {
		$scope.matchCommonDice(action_taker, skill_key);
		// TODO: Allow setting common action difficulty in the UI
		$scope.num_dice.$save().then(function(ref) {
			$scope.upgradeDiffDice(action_taker.temp_diff_upgrades);
			$scope.num_dice.$save();
		}, function(error) {
			console.log("Error:", error);
		});
	}
	
	$scope.actionTakenEffects = function(action_taker, char_key, skill_key) {
		$scope.resetTempDiceEffects(action_taker);
		
		if ($scope.using_genetically_engineered && action_taker.species === 'ARKANOFF') {
			if (char_key === 'BR' || char_key === 'AG') {
				$scope.using_genetically_engineered = false;
				$scope.action_tracker.genetically_engineered_used = true;
				action_taker.strain++;
			}
		}
		
		if (action_taker.talents["FRENZ"]) {
			if (skill_key === 'MELEE' || skill_key === 'BRAWL') {
				action_taker.strain += $scope.frenzied_attack_upgrades;
				$scope.frenzied_attack_upgrades = 0;
			}
		}
		
	
		$scope.action_tracker.$save();
		$scope.characters_array.$save(action_taker);
	}
	
	$scope.resetTempDiceEffects = function(action_taker) {
		action_taker.temp_boosts = 0;
		action_taker.temp_setbacks = 0;
		action_taker.temp_upgrades = 0;
		action_taker.temp_diff_upgrades = 0;
		
		$scope.action_tracker.boost_any[action_taker.ally_or_enemy] = 0;
	}
	
	$scope.takeAction = function(action_taker, skill_key) {
		// Account for out-of-turn actions, etc.
		$scope.incrementActionsTaken();
		
		let char_key = $scope.skill_info[skill_key].char_key;
		$scope.actionTakenEffects(action_taker, char_key, skill_key);
		$scope.removeAims(action_taker);
		
		var skill_info = $scope.skill_info[skill_key];
		var log_message = `${action_taker.name} uses ${skill_info.name} `;
		
		if ($scope.die_pool.succ <= 0) {
			log_message = log_message + ' but fails.';
			$scope.addLogEntry(log_message);
		} else {
			log_message = log_message + ' and succeeds.';
			$scope.addLogEntry(log_message);
		}
	}
	
	$scope.matchCritHealDice = function(action_taker, crit_heal_target, crit_to_heal, equipment_for_crit_heal) {
		$scope.matchCommonDice(action_taker, 'MED');
		$scope.num_dice.num_diff_dice = crit_to_heal.severity;
		if (!equipment_for_crit_heal) {
			$scope.num_dice.num_diff_dice++;
		}
		if (crit_heal_target === action_taker) {
			$scope.num_dice.num_diff_dice += 2;
		}
		$scope.num_dice.num_chal_dice = 0;
		
		$scope.num_dice.$save().then(function(ref) {
			$scope.upgradeDiffDice(action_taker.temp_diff_upgrades);
			$scope.num_dice.$save();
		}, function(error) {
			console.log("Error:", error);
		});
	}
	
	$scope.healCritical = function(action_taker, crit_heal_target, crit_to_heal) {
		$scope.incrementActionsTaken();
		
		let heal_word = 'heal';
		let heal_skill = 'MED';
		if (crit_heal_target.species === 'DROID') {
			let heal_world = 'repair'
			let heal_skill = 'MECH';
		}
		
		$scope.actionTakenEffects(action_taker, 'INT', heal_skill);
	
		if ($scope.die_pool.succ <= 0) {
			$scope.addLogEntry(`${action_taker.name} failed to ${heal_word} ${crit_heal_target.name}\'s ${crit_to_heal.name} critical injury.`);
			crit_to_heal.heal_attempt_made = true;
		} else {
			$scope.addLogEntry(`${action_taker.name} ${heal_word}ed ${crit_heal_target.name}\'s ${crit_to_heal.name} critical injury.`);
			let crit_index = crit_heal_target.criticals.indexOf(crit_to_heal);
			crit_heal_target.criticals.splice(crit_index, 1);
		}
		$scope.characters_array.$save(crit_heal_target);
	}
	
	$scope.matchDroidCritHealDice = function(action_taker, crit_heal_target, crit_to_heal) {
		$scope.matchCommonDice(action_taker, 'MECH');
		$scope.num_dice.num_diff_dice = crit_to_heal.severity;
		if (crit_heal_target === action_taker) {
			$scope.num_dice.num_diff_dice += 1;
		}
		$scope.num_dice.num_chal_dice = 0;
		
		$scope.num_dice.$save().then(function(ref) {
			$scope.upgradeDiffDice(action_taker.temp_diff_upgrades);
			$scope.num_dice.$save();
		}, function(error) {
			console.log("Error:", error);
		});
	}
	
	$scope.isMeleeSkill = function(skill_key) {
		if (skill_key === 'BRAWL' || skill_key === 'MELEE' || skill_key === 'LTSABER') {
			return true;
		}
		return false;
	}
	
	$scope.isRangedSkill = function(skill_key) {
		if (skill_key === 'RANGLT' || skill_key === 'RANGHVY' || skill_key === 'GUNN') {
			return true;
		}
		return false;
	}
	
	$scope.getPotentialTargetsToAttack = function(action_taker, damage_scale, show_non_scale_matching, chars_in_other_vehicles, chars_of_same_type) {
		if (!action_taker) {
			return [];
		}
		// TODO: Include Vehicles that contain enemies
		// Do this by collecting all the vehicles enemies are in, in a set or something so no dupes
		// First have to make the vehicle that people can be in the actual vehicle using ng-option (instead of a string)
		var enemy_chars = [];
		var enemy_vehicles_set = new Set();
		for (var i = 0; i < $scope.characters_array.length; i++) {
			let potential_target = $scope.characters_array[i];
			if (potential_target === action_taker) {
				continue;
			}
			if (potential_target.initiative_type === 'none') {
				continue;
			}
			// TODO: Have a checkbox that allows for including allies (?)
			if (!chars_of_same_type && potential_target.ally_or_enemy === action_taker.ally_or_enemy) {
				continue;
			}
			if (potential_target.char_type === 'Minion') {
				if (potential_target.wounds > $scope.getMinionGroupWT(potential_target)) {
					continue;
				}
			} else {
				if (potential_target.wounds > potential_target.wound_threshold || potential_target.strain > potential_target.strain_threshold) {
					continue;
				}
			}
			
			if (potential_target.vehicle) {
				enemy_vehicles_set.add($scope.vehicles_array.$getRecord(potential_target.vehicle));
			}
			if (potential_target.vehicle) {
				if (!chars_in_other_vehicles && potential_target.vehicle != action_taker.vehicle) {
					continue;
				}
			}
			enemy_chars.push(potential_target);
		}
		let enemy_vehicles_list = Array.from(enemy_vehicles_set);
		let non_disabled_enemy_vehicles = [];
		for (let i = 0; i < enemy_vehicles_list.length; i++) {
			let potential_enemy_vehicle = enemy_vehicles_list[i];
			if (potential_enemy_vehicle.hull_trauma > potential_enemy_vehicle.hull_trauma_threshold || potential_enemy_vehicle.system_strain > potential_enemy_vehicle > potential_enemy_vehicle.system_strain) {
				continue;
			}
			non_disabled_enemy_vehicles.push(potential_enemy_vehicle);
		}
		let targets = [];
		if (show_non_scale_matching || !damage_scale) {
			targets = enemy_chars.concat(non_disabled_enemy_vehicles);
		} else {
			if (damage_scale === 'personal') {
				targets = enemy_chars;
			} else { // if (damage_scale === 'planetary') {
				targets = non_disabled_enemy_vehicles;
			}
		}
		
		return targets;
	}
	
	$scope.getPotentialWeaponsForAttack = function(action_taker) {
		// TODO: Can remove this and in other places?
		if (!action_taker) {
			return [];
		}
		var personal_weapons = [];
		if (action_taker.weapons) {
			personal_weapons = action_taker.weapons.slice();
		}
		// TODO: What if their heands are full?
		// TODO: What if they have no arms?
		personal_weapons.push(action_taker.left_fist);
		
		// TODO: Add weapons for the vehicle the character is in
		// First have to make Characters hold onto the actual vehicles rather than strings
		var vehicle_weapons = [];
		if (action_taker.vehicle) {
			let vehicle = $scope.vehicles_array.$getRecord(action_taker.vehicle);
			vehicle_weapons = vehicle.weapons;
		}
		return personal_weapons.concat(vehicle_weapons);
	}
	
	// Helper function for matching Ab, Proff, Boost, and Setback for any attack roll (including Force Hurl_
	$scope.setSomeAttackDice = function(action_taker, target, skill_key, is_melee_attack, target_defense_zone, additional_setbacks) {
		$scope.matchCommonDice(action_taker, skill_key);
		
		let extra_boost_dice = 0;
		let extra_setback_dice = 0;
		
		// Setbacks
		extra_setback_dice += additional_setbacks;
		
		// Aim
		extra_boost_dice += action_taker.aims;
		
		if (target.target_type === 'character') {
			if (is_melee_attack) {
				// Melee Defense
				extra_setback_dice += target.def_melee;
				// Melee against prone gets +1 boost
				if (target.prone) {
					extra_boost_dice += 1;
				}
			} else { // (Assume it is a ranged attack)
				// Ranged Defense
				extra_setback_dice += target.def_ranged;
				// Ranged against prone gets +1 setback
				if (target.prone) {
					extra_setback_dice += 1;
				}
				// Cover
				extra_setback_dice += target.cover_bonus;
			}
			
		} else { // if (target.target_type === 'vehicle') {
			// Vehicle Defense Zones
			switch (target_defense_zone) {
				case 'fore':
					extra_setback_dice += target.def_fore;
					break;
				case 'aft':
					extra_setback_dice += target.def_aft;
					break;
				case 'port':
					extra_setback_dice += target.def_port;
					break;
				case 'starboard':
					extra_setback_dice += target.def_starboard;
					break;
				case 'least':
					if (target.silhouette <= 4) {
						extra_setback_dice += Math.min(target.def_fore, target.def_aft);
					} else {
						extra_setback_dice += Math.min(target.def_fore, target.def_aft, target.def_port, target.def_starboard);
					}
					break;
				case 'most':
				default:
					extra_setback_dice += Math.max(target.def_fore, target.def_aft, target.def_port, target.def_starboard);
					break;
			}
		}
		
		$scope.num_dice.num_boost_dice += extra_boost_dice;
		$scope.num_dice.num_setback_dice += extra_setback_dice;
	}
	
	$scope.matchAttackDice = function(action_taker, target, weapon, target_range, target_defense_zone) {
		// Skill Dice
		let skill_key = weapon.skill_key;
		let is_melee_attack = $scope.isMeleeSkill(skill_key)
		$scope.setSomeAttackDice(action_taker, target, skill_key, is_melee_attack, target_defense_zone, weapon.setback_adds);
				
		let target_silhouette = target.silhouette;
		if (weapon.vehicle_weapon) {
			let attacker_silhouette = $scope.vehicles_dict[action_taker.vehicle].silhouette;
			let silhouette_diff = attacker_silhouette - target_silhouette;
			if (silhouette_diff <= -2) {
				$scope.num_dice.num_diff_dice = 1;
			} else if (silhouette_diff <= 1) {
				$scope.num_dice.num_diff_dice = 2;
			} else if (silhouette_diff <= 2) {
				$scope.num_dice.num_diff_dice = 3;
			} else if (silhouette_diff <= 3) {
				$scope.num_dice.num_diff_dice = 4;
			} else { // silhouette_diff >= 4
				$scope.num_dice.num_diff_dice = 5;
			}
		} else {
			if (is_melee_attack) {
				// Melee attacks against other characters is always 2 difficulty
				$scope.num_dice.num_diff_dice = 2;
			} else { // Assume it's a ranged attack
				// TODO: Attacking at various ranges
				switch(target_range) {
					case 'engaged':
						if (skill_key === 'RANGHVY') {
							$scope.num_dice.num_diff_dice = 3;
						} else { // if (skill_key === 'RANGLT') {
							$scope.num_dice.num_diff_dice = 2;
						}
						break;
					case 'short':
						$scope.num_dice.num_diff_dice = 1;
						break;
					case 'medium':
						$scope.num_dice.num_diff_dice = 2;
						break;
					case 'long':
						$scope.num_dice.num_diff_dice = 3;
						break;
					case 'extreme':
						$scope.num_dice.num_diff_dice = 4;
						break;
					default:
						// If we don't know the range, just keep the dice the same
						break;
				}
			}
			
			let attacker_silhouette = action_taker.silhouette;
			let silhouette_diff = attacker_silhouette - target_silhouette;
			// Character attacking something of silhouette 2+ larger is -1 difficulty
			if (silhouette_diff <= -2) {
				$scope.num_dice.num_diff_dice = Math.max($scope.num_dice.num_diff_dice - 1, 0);
			// Character attacking something of silhouette 2- smaller is +1 difficulty
			} else if (silhouette_diff >= 2) {
				$scope.num_dice.num_diff_dice = $scope.num_dice.num_diff_dice + 1;
			}
		}
		
		$scope.num_dice.num_chal_dice = 0;
		$scope.num_dice.num_force_dice = 0;
		$scope.matchEnhanceDice(action_taker, skill_key);
		
		$scope.num_dice.$save().then(function(ref) {
			$scope.upgradeAttackDifficultyDice(action_taker, target, skill_key);
		}, function(error) {
			console.log("Error:", error);
		});
	}
	
	$scope.upgradeAttackDifficultyDice = function(action_taker, target, attack_skill) {
		let num_diff_upgrades = action_taker.temp_diff_upgrades;
		if (target.talents['ADV']) {
			num_diff_upgrades += target.talents['ADV'];
		}
		if ($scope.isMeleeSkill(attack_skill) && target.defensive_stance) {
			num_diff_upgrades += target.defensive_stance;
		}
		$scope.upgradeDiffDice(num_diff_upgrades);
		$scope.num_dice.$save();
	}
	
	$scope.addHit = function(target, skill) {
		let base_hit_info = {
			target_id: target.$id,
			crit_made: false,
			crit_boost: 0,
			crit_applied: false,
			hit_skill: skill,
		}
		if ($scope.action_tracker.hit_info) {
			$scope.action_tracker.hits_made.push(base_hit_info);
		} else {
			$scope.action_tracker.hits_made = [base_hit_info];
		}
	}
	
	$scope.hitTarget = function(action_taker, target, attack_skill, base_damage, pierce, breach, damage_type) {
		let damage = base_damage;
		damage += $scope.die_pool.succ;
		
		let first_hit = true;
		angular.forEach($scope.action_tracker.hits_made, function(value, key) {
			if (key.hit_skill === attack_skill) {
				first_hit = false;
			}
		});
		
		if (first_hit) {
			if (action_taker.talents['DEADACC-' + attack_skill]) {
				damage += action_taker.skill_values[attack_skill];
			}
			if (attack_skill === 'BRAWL' && action_taker.talents['FERSTR']) {
				damage += action_taker.talents['FERSTR'];
			}
		}
		
		if (target.target_type === 'character') {
			if (target.armor && target.armor.cortosis) {
				pierce = 0;
				breach = 0;
			}
			let hit_through_soak = $scope.applyDamageToCharacterTarget(target, damage, pierce, breach, damage_type);
			if (hit_through_soak) {
				$scope.addHit(target, attack_skill);
			}
		} else { // if (target.target_type === 'vehicle') {
			$scope.applyDamageToVehicleTarget(target, damage, pierce, breach, damage_type);
		}
	}
	
	$scope.hitTargetWithWeapon = function(action_taker, target, weapon) {
		let base_damage = 0;
		if (weapon.damage >= 1) {
			base_damage = weapon.damage;
		} else {
			let char_brawn = action_taker.char_values["BR"];
			base_damage = char_brawn + weapon.damage_add;
		}
		$scope.hitTarget(action_taker, target, weapon.skill_key, base_damage, weapon.pierce, weapon.breach, weapon.damage_scale);
	}
	
	$scope.attackTarget = function(action_taker, target, weapon) {
		$scope.incrementActionsTaken();
	
		
		action_taker.aims = 0;
		let char_key = $scope.skill_info[weapon.skill_key].char_key;
		$scope.actionTakenEffects(action_taker, char_key, weapon.skill_key);
	
		var log_message = `${action_taker.name} attacks ${target.name} with their ${weapon.name} `;
		if ($scope.die_pool.succ <= 0) {
			log_message = log_message + ' but misses.';
			$scope.addLogEntry(log_message);
			return;
		} else {
			log_message = log_message + ' and hits.';
			$scope.addLogEntry(log_message);
			
			$scope.hitTargetWithWeapon(action_taker, target, weapon);
		}
		
		$scope.action_tracker.$save();
	}
	
	// Returns true if the damage goes through the soak, false otherwise
	$scope.applyDamageToCharacterTarget = function(character, damage, pierce, breach, damage_type) {
		let starting_minions_in_group = 0;
		if (character.char_type === 'Minion') {
			starting_minions_in_group = $scope.getNumActiveMinions(character);
		}
	
		var totalPierce = pierce + (breach * 10);
		var soak_after_pierce = Math.max(0, character.soak - totalPierce);
		var real_damage = damage;
		if (damage_type === 'planetary') {
			real_damage = damage * 10;
		}
		var wounds_taken = Math.max(0, real_damage - soak_after_pierce);
		if (wounds_taken <= 0) {
			// TODO: Move this log out of applyDamageToCharacterTarget and into the attack/hurl functions that called this
			$scope.addLogEntry('But the attack fails to go through their soak.');
			return false;
		}
		character.wounds = character.wounds + wounds_taken;
		
		if (character.char_type === 'Minion') {
			$scope.addLogEntry(`${character.name} takes ${wounds_taken} wounds (${character.wounds}/${$scope.getMinionGroupWT(character)}).`);
			let new_minions_in_group = $scope.getNumActiveMinions(character);
			let num_minions_lost = starting_minions_in_group - new_minions_in_group;
			if (num_minions_lost > 0) {
				$scope.addLogEntry(`${character.name} lost ${num_minions_lost} minions. (${$scope.getNumActiveMinions(character)}/${character.num_in_group} minions remaining)`);
				if (new_minions_in_group <= 0) {
					$scope.addLogEntry(`Minion group ${character.name} has been destroyed.`);
				}
			}
		} else {
			$scope.addLogEntry(`${character.name} takes ${wounds_taken} wounds (${character.wounds}/${character.wound_threshold}).`);
			if (character.wounds > character.wound_threshold) {
				$scope.addLogEntry(`${character.name} passes out.`);
				// TODO: Move this to a 'go unconscious' function
				character.prone = true;
				character.aims = 0;
			} else {
				$scope.removeAims(character);
			}
		}
		
		$scope.characters_array.$save(character);
		return true;
	}
	
	// Returns true if the damage goes through armor, false otherwise
	$scope.applyDamageToVehicleTarget = function(vehicle, damage, pierce, breach, damage_type) {
		var totalBreach = (breach * 10) + pierce;
		var real_armor = vehicle.armor * 10;
		var real_damage = damage * 10;
		if (damage_type === 'personal') {
			real_damage = damage;
		}
		var armor_after_breach = Math.max(0, real_armor - totalBreach);
		var damage_taken = Math.max(0, real_damage - armor_after_breach);
		if (damage_taken <= 0) {
			$scope.addLogEntry('But the attack fails to go through its armor.');
			return false;
		}
		var vehicle_damage = damage_taken / 10;
		vehicle.hull_trauma = vehicle.hull_trauma + vehicle_damage;
		$scope.addLogEntry(`${vehicle.name} takes ${vehicle_damage} hull trauma (${vehicle.hull_trauma}/${vehicle.hull_trauma_threshold}).`);
		if (vehicle.hull_trauma > vehicle.hull_trauma_threshold) {
			$scope.addLogEntry(`${vehicle.name} is disabled.`)
		}
		$scope.vehicles_array.$save(vehicle);
		return true;
	}
	
	// Force Powers
	$scope.matchForceDice = function(action_taker) {
		$scope.num_dice.num_ab_dice = 0;
		$scope.num_dice.num_prof_dice = 0;
		$scope.num_dice.num_boost_dice = 0;
		$scope.num_dice.num_diff_dice = 0;
		$scope.num_dice.num_chal_dice = 0;
		$scope.num_dice.num_setback_dice = 0;
		$scope.num_dice.num_force_dice = action_taker.force_rating;
		$scope.num_dice.$save();
	}
	
	$scope.getMatchingForcePoints = function(action_taker) {
		if (!action_taker) {
			return 0;
		}
		if (action_taker.lightside_user) {
			return $scope.die_pool.light_side_points;
		}
		return $scope.die_pool.dark_side_points;
	}
	
	$scope.getNonMatchingForcePoints = function(action_taker) {
		if (!action_taker) {
			return 0;
		}
		if (action_taker.lightside_user) {
			return $scope.die_pool.dark_side_points;
		}
		return $scope.die_pool.light_side_points;
	}
	
	$scope.getAvailableForcePoints = function(action_taker) {
		if (!action_taker) {
			return 0;
		}
		return $scope.getMatchingForcePoints(action_taker) + $scope.force_powers.fp_converted;
	}
	
	$scope.getRemainingForcePoints = function(action_taker) {
		return $scope.getAvailableForcePoints(action_taker) - $scope.force_powers.fp_spent;
	}
	
	$scope.convertForcePoint = function(action_taker) {
		$scope.force_powers.fp_converted = $scope.force_powers.fp_converted + 1;
		$scope.action_tracker.$save();
		// TODO: Also flip a destiny
		action_taker.strain = action_taker.strain + 1;
		$scope.characters_array.$save(action_taker);
		// TODO: Make very verbose
		$scope.addLogEntry(`${action_taker.name} converted a force point for 1 strain (${action_taker.strain}/${action_taker.strain_threshold}).`);
	}
	
	$scope.canSpendFP = function(action_taker, num_fp) {
		return $scope.getRemainingForcePoints(action_taker) >= num_fp;
	}
	
	$scope.getRangeString = function(range_int) {
		switch (range_int) {
			case 0:
				return 'engaged';
			case 1:
				return 'short';
			case 2:
				return 'medium';
			case 3:
				return 'long';
			default:
				return 'extreme';
		}
	}
	
	$scope.getPotentialForcePowers = function(action_taker) {
		let potential_powers = [];
		if (action_taker.force_powers.enhance && action_taker.force_powers.enhance.force_leap) {
			potential_powers.push(action_taker.force_powers.enhance);
		}
		if (action_taker.force_powers.move && action_taker.force_powers.move.unlocked) {
			potential_powers.push(action_taker.force_powers.move);
		}
		return potential_powers;
	}
	
	$scope.getFPImage = function(lightside_user, invert) {
		if (lightside_user) {
			if (invert) {
				return './dice_images/darkside.png';
			}
			return './dice_images/lightside.png';
		}
		
		if (invert) {
			return './dice_images/lightside.png';
		}
		return './dice_images/darkside.png';
	}
	
	////Enhance
	// TODO: Simplify these two args to just one boolean?
	$scope.activateEnhanceBasic = function(action_taker, adding_succ) {
		$scope.force_powers.fp_spent = $scope.force_powers.fp_spent + 1;
		$scope.force_powers.$save().then(function(ref) {
			// TODO: Make these helper functions that add succ or adv to the die pool, cancelling out fails and threats rather than blindly adding
			if (adding_succ) {
				$scope.addSuccToResults(1);
				$scope.addLogEntry(`${action_taker.name} activated the Enhance force power to add [SUCC] to their roll.`);
			} else {
				$scope.addAdvToResults(1);
				$scope.addLogEntry(`${action_taker.name} activated the Enhance force power to add [ADV] to their roll.`);
			}
			$scope.die_pool.$save();
		});
	}
	
	// Init Force Leap
	$scope.forceLeap = function(action_taker) {
		$scope.incrementActionsTaken();
		
		$scope.action_tracker.force_roll_made = true;
		$scope.enhance_power.using_force_leap = true;
		$scope.action_tracker.$save();
	}
	
	// TODO: This should be able to be horizontal or vertical
	$scope.useEnhanceForceLeap = function(action_taker) {
		$scope.addLogEntry(`${action_taker.name} used the Enhance force power to make a horizontal Force Leap to somewhere within short range.`);
	}
	
	$scope.failEnhanceForceLeap = function(action_taker) {
		$scope.addLogEntry(`${action_taker.name} failed to use the Enhance force power to make a Force Leap.`);
	}
	
	// Activate the Force Leap
	$scope.activateEnhanceForceLeap = function() {
		$scope.force_powers.fp_spent = $scope.force_powers.fp_spent + 1;
		$scope.force_powers.$save().then(function(ref) {
			$scope.enhance_power.enhance_force_leap_activated = true;
			$scope.enhance_power.$save();
		}, function(error) {
			console.log("Error:", error);
		});
	}
	
	//// Move
	$scope.forceMoveObject = function(action_taker) {
		$scope.incrementActionsTaken();
		
		$scope.action_tracker.force_roll_made = true;
		$scope.move_power.using_move = true;
		$scope.move_power.using_move_basic = true;
		// (move_power is within action_tracker)
		$scope.action_tracker.$save();
	}
	
	$scope.matchForceHurl = function(action_taker, target, object_silhouette) {
		// Skill Dice
		$scope.setSomeAttackDice(action_taker, target, 'DISC', false, 'most', 0);
		
		$scope.num_dice.num_diff_dice = object_silhouette;
		$scope.num_dice.num_chal_dice = 0;
		$scope.num_dice.num_force_dice = action_taker.force_rating;
		$scope.num_dice.num_force_dice = action_taker.force_rating;
		
		$scope.num_dice.$save().then(function(ref) {
			$scope.upgradeAttackDifficultyDice(action_taker, target);
		}, function(error) {
			console.log("Error:", error);
		});
	}
	
	$scope.forceMoveHurl = function(action_taker, target, object_silhouette) {
		$scope.incrementActionsTaken();
	
		// Skill Dice, Boosts, and Setbacks
		$scope.setSomeAttackDice(action_taker, target, 'DISC', false, 'most', 0);
			
		action_taker.aims = 0;
		$scope.actionTakenEffects(action_taker, 'WIL', 'DISC');
		$scope.characters_array.$save(action_taker);
		
		$scope.action_tracker.roll_made = true;
		$scope.action_tracker.force_roll_made = true;
		
		if ($scope.die_pool.succ <= 0) {
			$scope.addLogEntry(`${action_taker.name} failed to use their Move force power to hurl an object of silhouette ${object_silhouette} at ${target.name}.`);
		} else {
			$scope.move_power.using_move = true;
			$scope.move_power.using_move_hurl = true;
			$scope.move_power.hurl_object_silhouette = object_silhouette;
		}
		
		$scope.action_tracker.$save();
	}
	
	$scope.useMoveBasic = function(action_taker, hurl_target) {
		if ($scope.move_power.using_move_basic) {
			$scope.addLogEntry(`${action_taker.name} used the Move force power to move an object of Silhouette ${$scope.move_power.strength} or less within ${$scope.getRangeString($scope.move_power.range)} somewhere else within ${$scope.getRangeString($scope.move_power.range)}.`);
		} else { // if ($scope.move_power.using_move_hurl) {
			let object_silhouette = $scope.move_power.hurl_object_silhouette;
			$scope.addLogEntry(`${action_taker.name} uses the Move force power to hurl an object of Silhouette ${object_silhouette} at ${hurl_target.name}`);
		
			let base_damage = 5;
			if (object_silhouette > 0) {
				base_damage = object_silhouette * 10;
			}
			
			$scope.hitTarget(
				action_taker,
				hurl_target,
				/* attack_skill = */ 'DISC',
				base_damage,
				/* pierce = */ 0,
				/* breach = */ 0,
				/* damage_type = */ 'personal',
			);
		}
	}
	
	$scope.failMoveBasic = function(action_taker, hurl_target) {
		if ($scope.move_power.using_move_basic) {
			$scope.addLogEntry(`${action_taker.name} failed to use the Move force power.`);
		} else { // if ($scope.move_power.using_move_hurl) {
			let object_silhouette = $scope.move_power.hurl_object_silhouette;
			$scope.addLogEntry(`${action_taker.name} failed to use the Move force power to hurl an object of Silhouette ${object_silhouette} at ${hurl_target.name}`);
		}
	}
	
	// Activate the Power
	
	$scope.activateMoveBasic = function() {
		$scope.force_powers.fp_spent = $scope.force_powers.fp_spent + 1;
		$scope.force_powers.$save().then(function(ref) {
			$scope.move_power.move_basic_activated = true;
			$scope.move_power.$save();
		}, function(error) {
			console.log("Error:", error);
		});
	}
	
	// Use Strength to Increase the Silhouette
	$scope.strengthMove = function(action_taker) {
		$scope.force_powers.fp_spent = $scope.force_powers.fp_spent + 1;
		$scope.force_powers.$save().then(function(ref) {
			$scope.move_power.strength = $scope.move_power.strength + action_taker.force_powers.move.strength;
			$scope.move_power.$save();
		}, function(error) {
			console.log("Error:", error);
		});
	}
	
	// Use Range to Increase the Range
	$scope.rangeMove = function(action_taker) {
		$scope.force_powers.fp_spent = $scope.force_powers.fp_spent + 1;
		$scope.force_powers.$save().then(function(ref) {
			$scope.move_power.range = $scope.move_power.range + action_taker.force_powers.move.range;
			$scope.move_power.$save();
		}, function(error) {
			console.log("Error:", error);
		});
	}
	
	// Maneuvers
	
	$scope.incrementManeuversTaken = function() {
		if (!$scope.general_info.in_combat) {
			return;
		}
		$scope.action_tracker.maneuvers_taken = $scope.action_tracker.maneuvers_taken + 1;
		$scope.action_tracker.$save();
	}
	
	$scope.move = function(action_taker, direction, moving_towards) {
		$scope.incrementManeuversTaken();
		$scope.removeAims(action_taker);
		$scope.leaveCover(action_taker);
		
		switch(direction) {
			case 'forward':
			case 'backward':
			case 'left':
			case 'right':
				$scope.addLogEntry(`${action_taker.name} moves ${direction}.`);
				break;
			case 'towards':
				$scope.addLogEntry(`${action_taker.name} moves towards ${moving_towards.name}.`);
				break;
			case 'engage':
				$scope.addLogEntry(`${action_taker.name} engages ${moving_towards.name}.`);
				break;
			default:
				$scope.addLogEntry(`{action_taker.name} moves.`);
				break;
		}
	}
	
	$scope.healWounds = function(target, wounds_to_heal) {
		let actual_wounds_healed = Math.min(wounds_to_heal, target.wounds);
		target.wounds = target.wounds - actual_wounds_healed;
		$scope.characters_array.$save(target);
		
		$scope.addLogEntry(`${target.name} healed ${actual_wounds_healed} wounds (${target.wounds}/${target.wound_threshold}).`);
	}
	
	$scope.applyStimpack = function(action_taker, stim_target) {
		$scope.incrementManeuversTaken();
		
		let wounds_to_heal = 5 - stim_target.stim_packs_used;
		stim_target.stim_packs_used = stim_target.stim_packs_used + 1;
	
		if (action_taker === stim_target) {
			$scope.addLogEntry(`${action_taker.name} applied a stimpack to themself (${action_taker.stim_packs_used}/5 stimpacks used).`);
		} else {
			$scope.addLogEntry(`${action_taker.name} applied a stimpack to ${stim_target.name} (${stim_target.stim_packs_used}/5 stimpacks used).`);
		}
	
		$scope.healWounds(stim_target, wounds_to_heal);
	}
	
	$scope.applyRepairPatch = function(action_taker, patch_target) {
		$scope.incrementManeuversTaken();
		
		patch_target.stim_packs_used = patch_target.stim_packs_used + 1;
		
		if (action_taker === patch_target) {
			$scope.addLogEntry(`${action_taker.name} applied a repair patch to themself (${action_taker.stim_packs_used}/5 repair patches used).`);
		} else {
			$scope.addLogEntry(`${action_taker.name} applied a repair patch to ${patch_target.name} (${patch_target.stim_packs_used}/5 repair patches used).`);
		}
		
		$scope.healWounds(patch_target, 3);
	}
	
	$scope.aim = function(action_taker) {
		$scope.incrementManeuversTaken();
		
		action_taker.aims = action_taker.aims + 1;
		$scope.characters_array.$save(action_taker);
		
		$scope.num_dice.num_boost_dice = $scope.num_dice.num_boost_dice + 1;
		$scope.num_dice.$save();
		
		$scope.addLogEntry(`${action_taker.name} aims.`);
	}
	
	$scope.standUp = function(action_taker) {
		$scope.incrementManeuversTaken();
		
		action_taker.prone = false;
		$scope.characters_array.$save(action_taker);
		$scope.addLogEntry(`${action_taker.name} stands up.`);
	}
	
	$scope.takeCover = function(action_taker) {
		$scope.incrementManeuversTaken();
		
		action_taker.cover_bonus = 1;
		$scope.characters_array.$save(action_taker);
		$scope.addLogEntry(`${action_taker.name} takes cover.`);
	}
	
	// Defensive Stance Talent Maneuver
	$scope.takeDefensiveStance = function(action_taker, num_upgrades) {
		$scope.incrementManeuversTaken();
		$scope.action_tracker.defensive_stance_taken = true;
	
		action_taker.strain += num_upgrades;
		action_taker.defensive_stance = num_upgrades;
		let time_v_times = 'time';
		if (num_upgrades > 1) {
			time_v_times = 'times';
		}
		$scope.addLogEntry(`${action_taker.name} took the Defensive Stance maneuver, taking ${num_upgrades} strain to upgrade incoming melee attacks ${num_upgrades} ${time_v_times} until the start of their next turn.`);
		
		$scope.action_tracker.$save();
		$scope.characters_array.$save(action_taker);
	}
	
	// Incidentals
	
	$scope.goProne = function(action_taker) {
		action_taker.prone = true;
		$scope.characters_array.$save(action_taker);
		$scope.addLogEntry(`${action_taker.name} goes prone.`);
	}
	
	// Get Potential Vehicles a Person Can Be In
	$scope.getPotentialVehicles = function() {
		// .$id : .name
		let vehicles_dict = {
			'': 'No Vehicle',
		}
		for (let i = 0; i < $scope.vehicles_array.length; i++) {
			let vehicle = $scope.vehicles_array[i];
			vehicles_dict[vehicle.$id] = vehicle.name;
		}
		return vehicles_dict;
	}
	
	// TODO: For users with the Enhance resilience ability, automatically add matching FP as success.
	$scope.recoverFromCritical = function(character, critical) {
		let resilience_dice = $scope.getSkillDice(character, 'RESIL');
		let recover_die_pool = new DicePool(resilience_dice[0], resilience_dice[1], 0, critical.severity, 0, 0, 0);
		recover_die_pool.roll();
		$scope.addRollLogEntry(recover_die_pool);
		if (recover_die_pool.succ > 0) {
			let crit_index = character.criticals.indexOf(critical);
			character.criticals.splice(crit_index, 1);
			$scope.addLogEntry(`${character.name} recovered from their ${critical.name} critical injury.`);
			return true;
		} else {
			$scope.addLogEntry(`${character.name} failed to recover from their ${critical.name} critical injury.`);
			return false;
		}
	}
	
	$scope.passOneDay = function() {
		$scope.remote_logs.$add(new Log()).then(function(ref) {
			$scope.day.$value++;
			$scope.day.$save();
			$scope.addLogEntry('--- One Day Passes ---');
			for (let i = 0; i < $scope.characters_array.length; i++) {
				let character = $scope.characters_array[i];
				
				character.stim_packs_used = 0;
				character.strain = 0;
				// Heal Wounds
				if (character.wounds > 0) {
					if (character.species === 'GENDAI') {
						character.wounds = 0;
						$scope.addLogEntry(`${character.name} regenerates all wounds (${character.wounds}/${character.wound_threshold}).`);
					} else {
						let wounds_healed = 1;
						if (character.species === 'TRAND') {
							wounds_healed = 2;
						}
						$scope.healWounds(character, wounds_healed);
					}
				}
				
				// Criticals
				if (character.criticals) {
					for (let j = 0; j < character.criticals.length; j++) {
						let critical = character.criticals[j];
						
						// Gen'dai can try to recover from criticals every 2 hours
						if (character.species === 'GENDAI') {
							let recovered_from_crit = false;
							for (let k = 0; k < 6; k++) {
								let recovered_from_crit = $scope.recoverFromCritical(character, critical);
								if (recovered_from_crit) {
									break;
								}
							}
							if (recovered_from_crit) {
								j--;
								continue;
							}
						}
						
						if (($scope.day.$value + critical.day_received) % 7 == 0) {
							// Recover from Critical with Resilience
							if (character.species != 'GENDAI') {
								let recovered_from_crit = $scope.recoverFromCritical(character, critical);
								if (recovered_from_crit) {
									j--;
									continue;
								}
							}
							// Reset ability to heal critical with medicine
							if (critical.heal_attempt_made) {
								$scope.addLogEntry(`Another attempt may be made to heal ${character.name}\'s ${critical.name} critical injury.`);
							}
							critical.heal_attempt_made = false;
						}
					}
				}
				
				$scope.characters_array.$save(character);
			}
			$scope.newLog();
		});
	}
	
	$scope.endEncounter = function() {
		$scope.newLog();
		$scope.remote_logs.$save($scope.remote_logs[$scope.remote_logs.length - 1]).then(function(ref) {
			$scope.addLogEntry('--- End Encounter ---');
			
			// End of Round Stuff for each Character
			function endEncounterCharacter(index) {
				if (index >= $scope.characters_array.length) {
					$scope.newLog();
					return
				}
				let character = $scope.characters_array[index];
				
				character.prone = false;
				character.cover_bonus = 0;
				
				$scope.resetTempDiceEffects(character);
				character.aims = 0;
				
				
				character.turn_taken = false;
				
				// Healing Strain at End of Encounter
				if (character.strain > 0) {
					let cool_dice = $scope.getSkillDice(character, 'COOL');
					let disc_dice = $scope.getSkillDice(character, 'DISC');
					let chosen_dice = null;
					
					let cool_sum = cool_dice[0] + cool_dice[1];
					let disc_sum = disc_dice[0] + disc_dice[1];
					if (cool_sum > disc_sum) {
						chosen_dice = cool_dice;
					} else if (disc_sum > cool_sum) {
						chosen_dice = disc_dice;
					} else { // if (cool_sum == disc_sum) {
						if (cool_dice[1] > disc_dice[1]) {
							chosen_dice = cool_dice;
						} else { // if (cool_dice[1] <= disc_dice[1]) {
							chosen_dice = disc_dice;
						}
					}
					
					let strain_die_pool = new DicePool(chosen_dice[0], chosen_dice[1], 0, 0, 0, 0, 0);
					strain_die_pool.roll();
					$scope.addRollLogEntry(strain_die_pool);
					let strain_healed = Math.min(strain_die_pool.succ, character.strain);
					character.strain -= strain_healed;
					$scope.addLogEntry(`${character.name} healed ${strain_healed} strain (${character.strain}/${character.strain_threshold}).`);
				}
				
				// Gendai Roll to Recover from Criticals at End of Encounters
				if (character.species === 'GENDAI') {
					if (character.criticals) {
						for (let i = 0; i < character.criticals.length; i++) {
							let critical = character.criticals[i];
							let recovered_from_crit = $scope.recoverFromCritical(character, critical);
							if (recovered_from_crit) {
								i--;
							}
						}
					}
				}
				
				$scope.startOfTurnResets(character);
				$scope.endOfTurnResets(character);
				
				$scope.characters_array.$save(character).then(function(ref) {
					endEncounterCharacter(index + 1);
				});
			}
			endEncounterCharacter(0);
		});
	
		$scope.action_tracker.boost_any = {
			'ally': 0,
			'enemy': 0,
		}
		$scope.action_tracker.$save();
		
		$scope.newTurnResets();
	}
	
	$scope.newTurnResets = function() {
		$scope.action_tracker.actions_taken = 0;
		$scope.action_tracker.maneuvers_taken = 0;
		$scope.action_tracker.actions_available = 1;
		$scope.action_tracker.maneuvers_available = 1;
		
		$scope.action_tracker.adv_spent = 0;
		$scope.action_tracker.triumph_spent = 0;
		$scope.action_tracker.threat_spent = 0;
		$scope.action_tracker.despair_spent = 0;
		
		$scope.action_tracker.roll_made = false;
		$scope.action_tracker.force_roll_made = false;
		
		$scope.action_tracker.hits_made = {};
		
		// Talent Maneuvers
		$scope.action_tracker.defensive_stance_taken = false;
		
		// Adv/Triumph/Threat/Despair Options
		$scope.action_tracker.boost_next_used = false;
		$scope.action_tracker.boost_any_used = false;
		$scope.action_tracker.setback_target_used = false;
		$scope.action_tracker.boost_target_used = false;
		$scope.action_tracker.setback_any_used = false;
		$scope.action_tracker.upgrade_target_diff_used = false;
		$scope.action_tracker.upgrade_ally_used = false;
		$scope.action_tracker.upgrade_any_diff_used = false;
		
		// Species Abilities
		$scope.action_tracker.genetically_engineered_used = false;
		
		$scope.action_tracker.$save();
		
		$scope.force_powers.fp_converted = 0;
		$scope.force_powers.fp_spent = 0;
		
		$scope.force_powers.$save();
		
		$scope.enhance_power.using_enhance_basic = false;
		$scope.enhance_power.enhance_force_leap_activated = false;
		$scope.enhance_power.using_force_leap = false;
		$scope.enhance_power.$save();
		
		$scope.move_power.using_move = false;
		$scope.move_power.using_move_basic = false;
		$scope.move_power.using_move_hurl = false;
		$scope.move_power.hurl_object_silhouette = 0;
		$scope.move_power.move_basic_activated = false;
		$scope.move_power.range = 1;
		$scope.move_power.strength = 0;
		$scope.move_power.$save();
	}
	
	// TODO: Refactor with $scope.upgradeDice
	$scope.getMinionSkillDice = function(minion, skill_key) {
		if ($scope.getNumActiveMinions(minion) <= 0) {
			return [0,0];
		}
	
		let char_key = $scope.skill_info[skill_key].char_key;
		let num_ab_dice = minion.char_values[char_key];
		let num_prof_dice = 0;
		if (!minion.group_skills[skill_key]) {
			return [num_ab_dice, 0];
		}
		
		for (let i = 0; i < $scope.getNumActiveMinions(minion) - 1; i++) {
			if (num_ab_dice > 0) {
				num_ab_dice--;
				num_prof_dice++;
			} else {
				num_ab_dice++;
			}
		}
		return [num_ab_dice, num_prof_dice];		
	}
	
	$scope.getSkillDice = function(character, skill_key) {
		if (character.char_type === 'Minion') {
			return $scope.getMinionSkillDice(character, skill_key);
		}
	
		var skill_rank = character.skill_values[skill_key];
		var char_key = $scope.skill_info[skill_key].char_key;
		var char_rank = character.char_values[char_key];
		var highest = Math.max(char_rank, skill_rank);
		var smallest = Math.min(char_rank, skill_rank);
		
		return [highest - smallest, smallest];
	}
	
	$scope.applyStatsFromWeaponInfo = function(weapon, weapon_info) {
		weapon.damage = weapon_info.damage;
		weapon.damage_add = weapon_info.damage_add;
		weapon.crit_rating = weapon_info.crit_rating;
		weapon.pierce = weapon_info.pierce;
		weapon.breach = weapon_info.breach;
	}
	
	$scope.readCharacterFiles = function(num_char_copies) {
		if (!num_char_copies) {
			num_char_copies = 1;
		}
		var files = document.getElementById("character-file-input").files;
		var reader = new FileReader();
		function readFile(index) {
			if (index >= files.length) {
				return
			}
			var file = files[index];
			reader.onloadend = function() {
				var xmlData = reader.result;
				for (var i = 0; i < num_char_copies; i++) {
					var char_num = 0;
					if (num_char_copies > 1) {
						char_num = i + 1;
					}
					$scope.importCharacter(xmlData, char_num);
				}
				readFile(index+1);
			};
			reader.readAsText(files[index]);
		}
		readFile(0);
	}
	
	$scope.importCharacter = function(xmlData, char_num) {
		var parser = new DOMParser();
		var xmlDoc = parser.parseFromString(xmlData,"text/xml");
		
		// Remove all NPCs
		var npc_nodes = xmlDoc.getElementsByTagName("NPCs");
		if (npc_nodes.length > 0) {
			npc_nodes[0].parentNode.removeChild(npc_nodes[0]);
		}
	
		var name = '';
		var char_name_nodes = xmlDoc.getElementsByTagName("CharName");
		if (char_name_nodes.length > 0) {
			name = char_name_nodes[0].childNodes[0].nodeValue;
		} else {
			name = xmlDoc.getElementsByTagName("Name")[0].childNodes[0].nodeValue;
		}
		if (char_num > 0) {
			name = name + ' ' + char_num;
		}
		
		// TODO: Get Type of Charcter
		let character_type = 'PlayerCharacter';
		let retrieved_char_type = getNodeValIfExists(xmlDoc, 'Type');
		if (retrieved_char_type) {
			character_type = retrieved_char_type;
		}
		
		let new_char = null;
		if (character_type === 'Minion') {
			new_char = new Minion(name);
		} else {
			new_char = new Character(name);
		}
		setBasicCharAttributes(xmlDoc, new_char);
		setCharCharacteristics(xmlDoc, new_char);
		setCharSkills(xmlDoc, new_char, $scope.skill_info);
		
		
		// Talents
		let talent_dict = {'ADV': 0};
		let talent_nodes = xmlDoc.getElementsByTagName('CharTalent');
		for (let i = 0; i < talent_nodes.length; i++) {
			let talent_node = talent_nodes[i];
			let num_new_ranks = 0;
			let key = talent_node.getElementsByTagName('Key')[0].childNodes[0].nodeValue;
			let selected_skills_nodes = talent_node.getElementsByTagName('SelectedSkills');
			if (selected_skills_nodes.length > 0) {
				key = key + '-' + getNodeValIfExists(selected_skills_nodes[0], "Key");
			}
			let purchased_nodes = talent_node.getElementsByTagName('Purchased');
			if (purchased_nodes.length > 0) {
				num_new_ranks++;
			}
			let ranks_nodes = talent_node.getElementsByTagName('Ranks');
			if (ranks_nodes.length > 0) {
				let num_ranks = parseInt(ranks_nodes[0].childNodes[0].nodeValue);
				num_new_ranks += num_ranks;
			}
			if (num_new_ranks) {
				if (talent_dict[key]) {
					talent_dict[key] += num_new_ranks;
				} else {
					talent_dict[key] = num_new_ranks;
				}
			}
		}
		new_char.talents = talent_dict;
		
		// Species
		var species_key_nodes = xmlDoc.getElementsByTagName("SpeciesKey");
		if (species_key_nodes.length > 0) {
			new_char.species = species_key_nodes[0].childNodes[0].nodeValue;
		}
		
		// Force Rating
		var force_rating_nodes = xmlDoc.getElementsByTagName("ForceRating");
		if (force_rating_nodes.length > 0) {
			new_char.force_rating = $scope.sumAttrNodeValues(force_rating_nodes[0]);
		}
		
		// Force Powers
		if (new_char.force_rating) {
			let enhance_power_data = {
				name: 'Enhance',
				unlocked: false,
				coordination: false,
				resilience: false,
				brawl: false,
				force_leap: false,
			}
			new_char.force_powers['enhance'] = enhance_power_data;
			let move_power_data = {
				name: 'Move',
				unlocked: false,
				strength: 0,
				range: 0,
				hurl: false,
				pull: false,
			};
			new_char.force_powers['move'] = move_power_data;
			
			let force_ability_nodes = xmlDoc.getElementsByTagName('CharForceAbility');
			for (let j = 0; j < force_ability_nodes.length; j++) {
				let ability_node = force_ability_nodes[j];
				let ability_key = ability_node.getElementsByTagName("Key")[0].childNodes[0].nodeValue;
				let upgrades = parseInt(getNodeValIfExists(ability_node, "Upgrades"));
				if (isNaN(upgrades)) {
					upgrades = 0;
				}
				let is_purchased = getNodeValIfExists(ability_node, "Purchased");
				if (is_purchased === "true") {
					upgrades++;
				}
				if (upgrades > 0) {
					// Enhance Nodes
					if (ability_key === 'ENHANCEBASIC') {
						new_char.force_powers['enhance'].unlocked = true;
					} else if (ability_key === 'ENHANCECONT1') {
						new_char.force_powers['enhance'].coordination = true;
					} else if (ability_key === 'ENHANCECONT2') {
						new_char.force_powers['enhance'].resilience = true;
					} else if (ability_key === 'ENHANCECONT5') {
						new_char.force_powers['enhance'].brawl = true;
					} else if (ability_key === 'ENHANCECONT3') {
						new_char.force_powers['enhance'].force_leap = true;
					// Move Nodes
					} else if (ability_key === 'MOVEBASIC') {
						new_char.force_powers['move'].unlocked = true;
					} else if (ability_key === 'MOVESTRENGTH') {
						new_char.force_powers['move'].strength += upgrades;
					} else if (ability_key === 'MOVERANGE') {
						new_char.force_powers['move'].range += upgrades;
					} else if (ability_key === 'MOVECONTROL1') {
						new_char.force_powers['move'].hurl = true;
					} else if (ability_key === 'MOVECONTROL2') {
						new_char.force_powers['move'].pull = true;
					}
				}
			}
		}
		
		// TODO: Get and set silhouette
		
		
		// Weapons
		var weapon_nodes = xmlDoc.getElementsByTagName("CharWeapon");
		for (var i = 0; i < weapon_nodes.length; i++) {
			let weapon_node = weapon_nodes[i];
			var held_nodes = weapon_node.getElementsByTagName("Held");
			var equipped_nodes = weapon_node.getElementsByTagName("Equipped");
			var shown_nodes = weapon_node.getElementsByTagName("Shown");
			if (
					(held_nodes.length != 0 && held_nodes[0].childNodes[0].nodeValue === "true") ||
					(equipped_nodes.length != 0 && equipped_nodes[0].childNodes[0].nodeValue === "true") ||
					(shown_nodes.length != 0 && shown_nodes[0].childNodes[0].nodeValue === "true") ||
					character_type === 'Minion'
				) {
				let weapon_key_nodes = weapon_node.getElementsByTagName("ItemKey")[0].childNodes;
				if (weapon_key_nodes.length <= 0) {
					continue;
				}
				let weapon_key = weapon_key_nodes[0].nodeValue;
				let weapon_info = $scope.weapon_info[weapon_key];
				
				let weapon_name = weapon_info.name;
				let rename_nodes = weapon_node.getElementsByTagName('Rename');
				if (rename_nodes.length > 0) {
					weapon_name = rename_nodes[0].childNodes[0].nodeValue;
				}
				
				let weapon = new WeaponEntry(weapon_name, weapon_info.skill_key);
				$scope.applyStatsFromWeaponInfo(weapon, weapon_info);
				// TODO: Check if it's planetary damage
				weapon.damage_scale = 'personal';
				
				// TODO: Refactor this and also apply to custom weapons (double-check NPC XML first)
				// Attachments + Attachment Mods
				let all_mods_nodes = weapon_node.getElementsByTagName('AllMods');
				if (all_mods_nodes.length > 0) {
					let mod_nodes = all_mods_nodes[0].getElementsByTagName('Mod');
					for (let j = 0; j < mod_nodes.length; j++) {
						let mod = mod_nodes[j];
						let mod_key_nodes = mod.getElementsByTagName('Key');
						if (mod_key_nodes.length > 0) {
							let mod_key = mod_key_nodes[0].childNodes[0].nodeValue;
							let count = 0;
							let count_nodes = mod.getElementsByTagName('Count');
							if (count_nodes.length > 0) {
								count = parseInt(count_nodes[0].childNodes[0].nodeValue);
							}
							switch(mod_key) {
								case 'DAMADD':
									if (weapon.damage > 0) {
										weapon.damage += count;
									} else {
										weapon.damage_add += count;
									}
									break;
								case 'SUPERIOR':
									if (weapon.damage > 0) {
										weapon.damage += 1;
									} else {
										weapon.damage_add += 1;
									}
									break;
								case 'SETBACKADD':
									weapon.setback_adds += count;
									break;
								default:
									break;
							}
						}
					}
				}
				
				new_char.weapons.push(weapon);
			}
			// TODO: Add code for including unarmed strike, including modifications for Trandoshans by looking at how UNARMED looks in Gutch's .xml
			// TODO: Also add arc welder for astromechs
		}
		// Fist
		let fist_name = 'Fist';
		let fist_crit = 5;
		let fist_damage_add = 0;
		if (new_char.species === 'TRAND') {
			fist_name = 'Claws';
			fist_crit = 3;
			fist_damage_add = 1;
		}
		new_char.left_fist = new WeaponEntry(fist_name, 'BRAWL');
		new_char.left_fist.crit_rating = fist_crit;
		new_char.left_fist.damage_add = fist_damage_add;
		
		// Custom Weapons
		let custom_weapon_nodes = xmlDoc.getElementsByTagName("AdvWeapon");
		for (let i = 0; i < custom_weapon_nodes.length; i++) {
			let weapon_node = custom_weapon_nodes[i];
			let name = weapon_node.getElementsByTagName('Name')[0].childNodes[0].nodeValue;
			let skill_key = weapon_node.getElementsByTagName('SkillKey')[0].childNodes[0].nodeValue;
			let damage = $scope.getXMLIntIfExists(weapon_node, 'Damage');
			let damage_add = $scope.getXMLIntIfExists(weapon_node, 'DamageAdd');
			let crit_rating = $scope.getXMLIntIfExists(weapon_node, 'Crit');
			// TODO: Vicious
			
			
			let pierce = 0;
			let breach = 0;
			let descriptor_nodes = weapon_node.getElementsByTagName('Descriptor');
			for (let j = 0; j < descriptor_nodes.length; j++) {
				let descriptor_node = descriptor_nodes[j];
				let descriptor_key = descriptor_node.getElementsByTagName('Key')[0].childNodes[0].nodeValue;
				let count = $scope.getXMLIntIfExists(descriptor_node, 'Count');
				if (descriptor_key === 'PIERCE') {
					pierce = count;
				} else if (descriptor_key === 'BREACH') {
					breach = count;
				}
			}
			
			let weapon = new WeaponEntry(name, skill_key);
			weapon.damage = damage;
			weapon.damage_add = damage_add;
			weapon.pierce = pierce;
			weapon.breach = breach;
			weapon.crit = crit_rating;
			
			new_char.weapons.push(weapon);
		}
		
		var armor = null;
		var armor_nodes = xmlDoc.getElementsByTagName("CharArmor");
		for (var i = 0; i < armor_nodes.length; i++) {
			var equipped_nodes = weapon_nodes[i].getElementsByTagName("Equipped");
			if (equipped_nodes.length != 0 && equipped_nodes[0].childNodes[0].nodeValue === "true") {
				var cortosis = false;
				var armor_mod_nodes = armor_nodes[i].getElementsByTagName("Mod");
				for (var j = 0; j < armor_mod_nodes.length; j++) {
					var mod_key_value = getNodeValIfExists(armor_mod_nodes[j], "Key");
					if (mod_key_value === 'CORTOSIS') {
						cortosis = true;
					}
				}
				new_char.armor = new ArmorEntry(cortosis);
			}
		}
		
		$scope.$apply(function () {
			$scope.characters_array.$add(new_char);
			$scope.debug = new_char;
		});
		
	}
	
	$scope.getXMLIntIfExists = function(xmlData, nodeName) {
		var nodes = xmlData.getElementsByTagName(nodeName);
		if (nodes.length <= 0) {
			return 0;
		}
		return parseInt(nodes[0].childNodes[0].nodeValue);
	}
	
	$scope.importCustomVehicle = function(xmlData) {
		var parser = new DOMParser();
		var xmlDoc = parser.parseFromString(xmlData,"text/xml");
		
		var vehicle_key = xmlDoc.getElementsByTagName("ItemKey")[0].childNodes[0].nodeValue;
		var vehicle_info = $scope.vehicle_info[vehicle_key];
		
		var name = xmlDoc.getElementsByTagName("Name")[0].childNodes[0].nodeValue;
		
		var weapons = vehicle_info.weapons.slice();
		var weapon_upgrade_nodes = xmlDoc.getElementsByTagName("WeaponUpgrade");
		for (var i = 0; i < weapon_upgrade_nodes.length; i++) {
			var weapon_key = weapon_upgrade_nodes[i].getElementsByTagName("WeapKey")[0].childNodes[0].nodeValue;
			let weapon_info = $scope.weapon_info[weapon_key];
			var weapon = new WeaponEntry(weapon_info.name, weapon_info.skill_key);
			$scope.applyStatsFromWeaponInfo(weapon, weapon_info);
			// TODO: Check if damage scale actually personal
			weapon.damage_scale = 'planetary';
			weapon.vehicle_weapon = true;
			weapons.push(weapon);
		}
		var ordnance_nodes = xmlDoc.getElementsByTagName("CharWeapon");
		for (var i = 0; i < ordnance_nodes.length; i++) {
			var weapon_key = ordnance_nodes[i].getElementsByTagName("ItemKey")[0].childNodes[0].nodeValue;
			let weapon_info = $scope.weapon_info[weapon_key];
			var weapon = new WeaponEntry(weapon_info.name, weapon_info.skill_key);
			$scope.applyStatsFromWeaponInfo(weapon, weapon_info);
			// TODO: Check if damage scale actually personal
			weapon.damage_scale = 'planetary';
			weapon.vehicle_weapon = true;
			weapons.push(weapon);
		}
		
		var vehicle = new Vehicle(
			name,
			vehicle_info.model,
			vehicle_info.hull_trauma_threshold,
			vehicle_info.system_strain_threshold,
			vehicle_info.armor,
			vehicle_info.def_fore,
			vehicle_info.def_aft,
			vehicle_info.def_port,
			vehicle_info.def_starboard,
			weapons,
			vehicle_info.silhouette,
			vehicle_info.speed,
			vehicle_info.handling,
		);
		$scope.vehicles_array.$add(vehicle);
	}
	
	$scope.copyVehicleFromInfo = function(vehicle_info_key, num_copies) {
		var num_to_copy = num_copies;
		if (num_to_copy <= 0) {
			num_to_copy = 1;
		}
		for (var i = 0; i < num_to_copy; i++) {
			var vehicle_info = $scope.vehicle_info[vehicle_info_key];
			var name = vehicle_info.name;
			if (num_copies > 1) {
				name = name + ' ' + (i + 1);
			}
			var vehicle = new Vehicle(
				name,
				vehicle_info.name,
				vehicle_info.hull_trauma_threshold,
				vehicle_info.system_strain_threshold,
				vehicle_info.armor,
				vehicle_info.def_fore,
				vehicle_info.def_aft,
				vehicle_info.def_port,
				vehicle_info.def_starboard,
				vehicle_info.weapons,
				vehicle_info.silhouette,
				vehicle_info.speed,
				vehicle_info.handling,
			);
			$scope.vehicles_array.$add(vehicle);
		}
	}
	
	$scope.readCustomVehicle = function() {
		var file = document.getElementById("custom-vehicle-file-input").files[0];
		var reader = new FileReader();
		reader.onloadend = function() {
			var xmlData = reader.result;
			$scope.importCustomVehicle(xmlData);
		};
		reader.readAsText(file);
	}
	
	$scope.sumAttrNodeValues = function(xmlNode) {
		var node_children = xmlNode.childNodes;
		var sum = 0;
		for (var i = 0; i < node_children.length; i++) {
			if(node_children[i].nodeType !== Node.TEXT_NODE) {
				var value = parseInt(node_children[i].childNodes[0].nodeValue);
				if (isNaN(value) != true) {
					sum += value;
				}
			}
		}
		return sum;
	}
	
	$scope.sumAttrNodesIgnoring = function(xmlNode, tagsToIgnore) {
		for (var i = 0; i < tagsToIgnore.length; i++) {
			var nodes_for_tag = xmlNode.getElementsByTagName(tagsToIgnore[i]);
			if (nodes_for_tag.length > 0) {
				nodes_for_tag[0].parentNode.removeChild(nodes_for_tag[0]);
			}
		}
		return $scope.sumAttrNodeValues(xmlNode);
	}
	
	$scope.readSkillData = function() {
		$scope.skill_info.$remove();
	
		var file = document.getElementById("skill-data-input").files[0];
		var reader = new FileReader();
		reader.onloadend = function() {
			var xmlData = reader.result;
			$scope.uploadSkillData(xmlData);
		};
		reader.readAsText(file);
	}
	
	$scope.uploadSkillData = function(xmlData) {
		var parser = new DOMParser();
		var xmlDoc = parser.parseFromString(xmlData,"text/xml");
		skill_nodes = xmlDoc.getElementsByTagName("Skill");
		for (var i = 0; i < skill_nodes.length; i++) {
			var skill_key = skill_nodes[i].getElementsByTagName("Key")[0].childNodes[0].nodeValue;
			var name = skill_nodes[i].getElementsByTagName("Name")[0].childNodes[0].nodeValue;
			var char_key = skill_nodes[i].getElementsByTagName("CharKey")[0].childNodes[0].nodeValue;
			$scope.skill_info[skill_key] = {
				"name": name,
				"char_key": char_key,
			}
		}
		
		$scope.skill_info.$save();
		
		$scope.debug = $scope.skill_info;
	}
	
	$scope.readWeaponData = function() {
		// $scope.weapon_info.$remove();
	
		var file = document.getElementById("weapon-data-input").files[0];
		var reader = new FileReader();
		reader.onloadend = function() {
			var xmlData = reader.result;
			$scope.uploadWeaponData(xmlData);
		};
		reader.readAsText(file);
	}
	
	$scope.uploadWeaponData = function(xmlData) {
	
		let parser = new DOMParser();
		let xmlDoc = parser.parseFromString(xmlData,"text/xml");
		weapon_nodes = xmlDoc.getElementsByTagName("Weapon");
		for (var i = 0; i < weapon_nodes.length; i++) {
			var weapon_key = weapon_nodes[i].getElementsByTagName("Key")[0].childNodes[0].nodeValue;
			var weapon_name = weapon_nodes[i].getElementsByTagName("Name")[0].childNodes[0].nodeValue;
			var skill_key = weapon_nodes[i].getElementsByTagName("SkillKey")[0].childNodes[0].nodeValue;
			
			var damage_nodes = weapon_nodes[i].getElementsByTagName("Damage");
			var damage_add_nodes = weapon_nodes[i].getElementsByTagName("DamageAdd");
			let crit_nodes = weapon_nodes[i].getElementsByTagName("Crit");
			var weapon_damage = 0;
			var damage_add = 0;
			let crit_rating = 0;
			if (damage_nodes.length != 0) {
				weapon_damage = parseInt(damage_nodes[0].childNodes[0].nodeValue);
			}
			if (damage_add_nodes.length != 0) {
				damage_add = parseInt(damage_add_nodes[0].childNodes[0].nodeValue);
			}
			if (crit_nodes.length != 0) {
				crit_rating = parseInt(crit_nodes[0].childNodes[0].nodeValue);
			}
			
			var pierce = 0;
			var breach = 0;
			var quality_nodes = weapon_nodes[i].getElementsByTagName("Quality");
			for (var j = 0; j < quality_nodes.length; j++) {
				var quality_key = quality_nodes[j].getElementsByTagName("Key")[0].childNodes[0].nodeValue;
				if (quality_key === "PIERCE") {
					var num_pierce = parseInt(quality_nodes[j].getElementsByTagName("Count")[0].childNodes[0].nodeValue);
					pierce = pierce + num_pierce;
				} else if (quality_key == "BREACH") {
					var num_breach = parseInt(quality_nodes[j].getElementsByTagName("Count")[0].childNodes[0].nodeValue);
					breach = breach + num_breach;
				}
			}
			
			$scope.weapon_info[weapon_key] = {
				"name": weapon_name,
				"damage": weapon_damage,
				"damage_add": damage_add,
				"crit_rating": crit_rating,
				"pierce": pierce,
				"breach": breach,
				"skill_key": skill_key,
			}
		}
		
		$scope.weapon_info.$save();
		
		$scope.debug = $scope.weapon_info;
	}
	
	$scope.readVehicleData = function() {
		$scope.vehicle_info.$remove();
	
		var files = document.getElementById("vehicle-info-file-input").files;
		var reader = new FileReader();
		function readFile(index) {
			if (index >= files.length) {
				return
			}
			var file = files[index];
			reader.onloadend = function() {
				var xmlData = reader.result;
				$scope.importVehicleInfo(xmlData);
				readFile(index+1);
			};
			reader.readAsText(files[index]);
		}
		readFile(0);
		$scope.vehicle_info.$save();
	}
	
	$scope.importVehicleInfo = function(xmlData) {
		let parser = new DOMParser();
		let xmlDoc = parser.parseFromString(xmlData,"text/xml");
		
		// TODO: Not safe because weapons will have "KEY" nodes as well
		var vehicle_key = xmlDoc.getElementsByTagName("Key")[0].childNodes[0].nodeValue;
		var name = xmlDoc.getElementsByTagName("Name")[0].childNodes[0].nodeValue;
		var hullTraumaThreshold = 0;
		var hullTraumaNodes = xmlDoc.getElementsByTagName("HullTrauma");
		if (hullTraumaNodes.length > 0) {
			hullTraumaThreshold = parseInt(hullTraumaNodes[0].childNodes[0].nodeValue);
		}
		var systemStrainThreshold = parseInt(xmlDoc.getElementsByTagName("SystemStrain")[0].childNodes[0].nodeValue);
		var armor = 0;
		var armorNodes = xmlDoc.getElementsByTagName("Armor");
		if (armorNodes.length > 0) {
			armor = parseInt(armorNodes[0].childNodes[0].nodeValue);
		}
		
		var defFore = $scope.getXMLIntIfExists(xmlDoc, "DefFore");
		var defAft = $scope.getXMLIntIfExists(xmlDoc, "DefAft");
		var defPort = $scope.getXMLIntIfExists(xmlDoc, "DefPort");
		var defStarboard = $scope.getXMLIntIfExists(xmlDoc, "DefStarboard");
		
		var silhouette = $scope.getXMLIntIfExists(xmlDoc, "Silhouette");
		var speed = $scope.getXMLIntIfExists(xmlDoc, "Speed");
		var handling = $scope.getXMLIntIfExists(xmlDoc, "Handling");
		
		var weapons = [];
		var weapon_nodes = xmlDoc.getElementsByTagName("VehicleWeapon");
		for (var i = 0; i < weapon_nodes.length; i++) {
			var weapon_node = weapon_nodes[i];
			// TODO: Actually do things with Quality Nodes, like 'Linked'
			var quality_nodes = weapon_node.getElementsByTagName("Qualities");
			if (quality_nodes.length > 0) {
				weapon_node.removeChild(quality_nodes[0]);
			}
			// TODO: Check if the weapon actually uses personal damage
			var weapon_key = weapon_node.getElementsByTagName("Key")[0].childNodes[0].nodeValue;
			let weapon_info = $scope.weapon_info[weapon_key];
			if (!weapon_info) {
				console.log('While importing vehicle info, failed to find weapon info for key ' + weapon_key + '.');
				continue;
			}
			var weapon = new WeaponEntry(weapon_info.name, weapon_info.skill_key);
			$scope.applyStatsFromWeaponInfo(weapon, weapon_info);
			// TODO: Check if damage scale actually personal
			weapon.damage_scale = 'planetary';
			weapon.vehicle_weapon = true;
			weapons.push(weapon);
		}
		
		$scope.vehicle_info[vehicle_key] = {
			"name": name,
			"model": name,
			"hull_trauma_threshold": hullTraumaThreshold,
			"system_strain_threshold": systemStrainThreshold,
			"armor": armor,
			"weapons": weapons,
			"def_fore": defFore,
			"def_aft": defAft,
			"def_port": defPort,
			"def_starboard": defStarboard,
			"silhouette": silhouette,
			"speed": speed,
			"handling": handling,
		}
		$scope.vehicle_info.$save();
	}
	
	$scope.downloadXMLFileData = function(url) {
		var Connect = new XMLHttpRequest();
		// Define which file to open and
		// send the request.
		Connect.open("GET", url, false);
		Connect.setRequestHeader("Content-Type", "text/xml");
		Connect.send(null);
		// Place the response in an XML document.
		var TheDocument = Connect.responseXML;
		return TheDocument;
	}
	
	$scope.addNewItem = function(name, price, rarity) {
		var newItem = new ItemEntry(name, price, rarity);
		$scope.item_entries.$add(newItem);
	}
	
	$scope.makePurchases = function(buyer, purchase_skill, rarity_mod) {
	
		for (var i = 0; i < $scope.item_entries.length; i++) {
			item_entry = $scope.item_entries[i];
			
			// TODO: Make skill a choice between Streetwise or Negotiation
			var skill_rank = buyer.skill_values[purchase_skill];
			var char_key = $scope.skill_info[purchase_skill].char_key;
			var char_rank = buyer.char_values[char_key];
			var highest = Math.max(char_rank, skill_rank);
			var smallest = Math.min(char_rank, skill_rank);
			var num_prof_dice = smallest;
			var num_ab_dice = highest - smallest;
			
			// TODO: Add in planetary modifiers to rarity
			modified_rarity = Math.max(item_entry.rarity + rarity_mod, 0);
			num_diff_dice = Math.floor(modified_rarity / 2);
			
			// TODO: Add the option of boosts, setbacks, and difficulty upgrades
			var dice_pool = new DicePool(num_ab_dice, num_prof_dice, 0, num_diff_dice, 0, 0, 0);
			dice_pool.roll();
			item_entry.die_pool = dice_pool;
			item_entry.roll_made = true;
			
			$scope.item_entries.$save(item_entry);
		}
	}
	
	$scope.getSellPercentage = function(numSucc, numThreat) {
		var base_percent = Math.min(numSucc, 3) * 25;
		var lowered_amount = numThreat * 5;
		return base_percent - lowered_amount;
	}
	
	$scope.rollInitiative = function() {
		$scope.newLog();
	
		$scope.initSyncObject.initiative_turn = 0;
		$scope.initSyncObject.$save();
		$scope.init_order_array.$ref().remove();
		let temp_init_order = [];
		for (var i = 0; i < $scope.characters_array.length; i++) {
			let character = $scope.characters_array[i];
			var num_ab_dice = 0;
			var num_prof_dice = 0;
			if (character.initiative_type === "cool") {
				var dice_needed = $scope.getSkillDice(character, "COOL");
				num_ab_dice = dice_needed[0];
				num_prof_dice = dice_needed[1];
			} else if (character.initiative_type === "vigilance") {
				var dice_needed = $scope.getSkillDice(character, "VIGIL");
				num_ab_dice = dice_needed[0];
				num_prof_dice = dice_needed[1];
			} else {
				continue;
			}
			// TODO: Custom initiative_type
			
			var dice_pool = new DicePool(num_ab_dice, num_prof_dice, 0, 0, 0, 0, 0);
			dice_pool.roll();
			character.initiative_roll = dice_pool;
			
			if (character.ally_or_enemy === "ally") {
				slot = new AllySlot(dice_pool.succ, dice_pool.adv);
			} else {
				slot = new EnemySlot(dice_pool.succ, dice_pool.adv);
			}
			temp_init_order.push(slot);
		}
		temp_init_order.sort($scope.initiativeCompator);
		temp_init_order.push(new EndOfRoundSlot());
		for (let i = 0; i < temp_init_order.length; i++) {
			$scope.init_order_array.$add(temp_init_order[i]);
		}
		
		for (let i = 0; i < $scope.characters_array.length; i++) {
			let character = $scope.characters_array[i];
			character.turn_taken = false;
			$scope.characters_array.$save(character);
		}
	}
	
	$scope.getInitiativeOrder = function() {
		if ($scope.initSyncObject.initiative_turn >= $scope.init_order_array.length) {
			return [];
		}
		var initiative_slots = [];
		for (var i = $scope.initSyncObject.initiative_turn; i < $scope.init_order_array.length; i++) {
			initiative_slots.push($scope.init_order_array[i]);
		}
		for (var i = 0; i < $scope.initSyncObject.initiative_turn; i++) {
			initiative_slots.push($scope.init_order_array[i]);
		}
		return initiative_slots;
	}
	
	$scope.needToStartOfTurnReset = function(action_taker) {
		if (!action_taker) {
			return false;
		}
		if ($scope.action_tracker.actions_taken > 0) {
			return false;
		}
		if ($scope.action_tracker.maneuvers_taken > 0) {
			return false;
		}
		if (action_taker.defensive_stance > 0) {
			return true;
		}
		return false;
	}
	
	$scope.startOfTurnResets = function(action_taker) {
		action_taker.defensive_stance = 0;
	}
	
	$scope.endOfTurnResets = function(action_taker) {
	
	}
	
	$scope.nextTurn = function() {
		$scope.turn_number.turn_number += 1;
		$scope.turn_number.$save();
	
		$scope.initSyncObject.initiative_turn = $scope.initSyncObject.initiative_turn + 1;
		if ($scope.initSyncObject.initiative_turn >= $scope.init_order_array.length) {
			$scope.initSyncObject.initiative_turn = 0;
		} else if ($scope.action_taker) {
			// If it's not a new round, mark the current character's turn as taken
			$scope.action_taker.turn_taken = true;
			$scope.endOfTurnResets($scope.action_taker);
			$scope.characters_array.$save($scope.action_taker);
		}
		
		// End of Round
		if ($scope.init_order_array[$scope.initSyncObject.initiative_turn].type === 'end_of_round') {
			$scope.remote_logs.$add(new Log()).then(function(ref) {
				$scope.addLogEntry("--- End of Round ---");
				
				// End of Round Effects
				for (let i = 0; i < $scope.characters_array.length; i++) {
					let character = $scope.characters_array[i];
					character.turn_taken = false;
					if (character.species === 'GENDAI') {
						if (character.wounds > 0) {
							character.wounds = character.wounds - 1;
							$scope.addLogEntry(`${character.name} heals 1 wound from their regeneration (now ${character.wounds}/${character.wound_threshold}).`);
						}
					}
					$scope.characters_array.$save(character);
				}
				
				$scope.nextTurn();
			});
			return;
		}
		
		$scope.initSyncObject.$save();
		
		$scope.newLog();
		
		$scope.newTurnResets();
	}
	
	$scope.initiativeCompator = function(a, b) {
		var succ_diff = b.succ - a.succ;
		if (succ_diff != 0) {
			return succ_diff;
		}
		var adv_diff = b.adv - a.adv;
		if (adv_diff != 0) {
			return adv_diff;
		}
		if (a.ally_or_enemy === "ally" && b.ally_or_enemy === "enemy") {
			return -1;
		}
		if (a.ally_or_enemy === "enemy" && b.ally_or_enemy === "ally") {
			return 1;
		}
		return 0;
	}
	
	function download(content, fileName, contentType) {
		var a = document.createElement("a");
		var file = new Blob([content], {type: contentType});
		a.href = URL.createObjectURL(file);
		a.download = fileName;
		a.click();
	}
	
	$scope.weapon_damage_type = 'personal';
	
	// Die Roller
	var dice_roller_ref = firebase.database().ref().child("dice_roller");
	$scope.dice_roller = $firebaseObject(dice_roller_ref);
	var die_pool_ref = dice_roller_ref.child("die_pool");
	$scope.die_pool = $firebaseObject(die_pool_ref);
	var num_dice_ref = dice_roller_ref.child("num_dice");
	$scope.num_dice = $firebaseObject(num_dice_ref);
	
	// Logs
	var remote_logs_ref = firebase.database().ref().child("remote_logs");
	// download the data into a local object
	// var syncObject = $firebaseObject(ref);
	// synchronize the object with a three-way data binding
	// click on `index.html` above to see it used in the DOM!
	// syncObject.$bindTo($scope, "remote_logs");
	$scope.remote_logs = $firebaseArray(remote_logs_ref);
	
	// Characters
	var characters_ref = firebase.database().ref().child("characters");
	$scope.characters_dict = $firebaseObject(characters_ref);
	$scope.characters_array = $firebaseArray(characters_ref);
	
	// Vehicles
	var vehicles_ref = firebase.database().ref().child("vehicles");
	$scope.vehicles_dict = $firebaseObject(vehicles_ref);
	$scope.vehicles_array = $firebaseArray(vehicles_ref);
	
	
	// Initiative
	var initiative_order_ref = firebase.database().ref().child("initiative").child("initiative_order");
	$scope.init_order_array = $firebaseArray(initiative_order_ref);
	
	var initiative_turn_ref = firebase.database().ref().child("initiative");
	$scope.initSyncObject = $firebaseObject(initiative_turn_ref);
	
	// Action Tracker
	var action_tracker_ref = firebase.database().ref().child("action_tracker");
	$scope.action_tracker = $firebaseObject(action_tracker_ref);
	// Force Powers
	var force_powers_ref = action_tracker_ref.child("force_powers");
	$scope.force_powers = $firebaseObject(force_powers_ref);
	var enhance_power_ref = force_powers_ref.child("enhance");
	$scope.enhance_power = $firebaseObject(enhance_power_ref);
	var move_power_ref = force_powers_ref.child("move");
	$scope.move_power = $firebaseObject(move_power_ref);
	// Turn Number
	var turn_number_ref = action_tracker_ref.child("round_tracker");
	$scope.turn_number = $firebaseObject(turn_number_ref);
	var stopNextTurnBeep = $scope.turn_number.$watch(function() {
		let x = document.getElementById("nextTurnBeep");
		x.volume = 0.8;
		x.play();
	});
	
	// Day
	let day_ref = firebase.database().ref().child("day");
	$scope.day = $firebaseObject(day_ref);
	
	// Skill Data
	var skill_data_ref = firebase.database().ref().child("skill_info");
	$scope.skill_info = $firebaseObject(skill_data_ref);
	// Weapon Data
	var weapon_data_ref = firebase.database().ref().child("weapon_info");
	$scope.weapon_info = $firebaseObject(weapon_data_ref);
	// Vehicle Data
	var vehicle_data_ref = firebase.database().ref().child("vehicle_info");
	$scope.vehicle_info = $firebaseObject(vehicle_data_ref);
	
	// General Info
	var general_info_ref = firebase.database().ref().child("general_info");
	$scope.general_info = $firebaseObject(general_info_ref);
	
	// Item Buyer
	var item_buyer_ref = firebase.database().ref().child("item_buyer");
	$scope.item_buyer = $firebaseObject(item_buyer_ref);
	var item_entries_ref = item_buyer_ref.child("item_entries");
	$scope.item_entries = $firebaseArray(item_entries_ref);

	$scope.debug = 'debug'
	
	
	class Log {
		constructor() {
			this.log_entries = [];
			
			this.id = 'TODO: uuid';
		}
	}
	
	class LogEntry {
		constructor() {
			this.text = '';
			
			this.dice_image_urls = [];
			this.succ = 0;
			this.adv = 0;
			this.triumph = 0;
			this.fail = 0;
			this.threat = 0;
			this.despair = 0;
			this.light_side_points = 0;
			this.dark_side_points = 0;
		}
	}
	
	$scope.addLogEntry = function(text) {
		var log_entry = new LogEntry();
		log_entry.text = text;
		var current_log = $scope.remote_logs[$scope.remote_logs.length - 1];
		if (current_log.log_entries) {
			current_log.log_entries.push(log_entry);
			$scope.remote_logs.$save(current_log);
		} else {
			current_log.log_entries = [log_entry];
			$scope.remote_logs.$save(current_log);
		}
	}
	
	$scope.addRollLogEntry = function(die_pool) {
		let log_entry = new LogEntry();
		log_entry.dice_image_urls = die_pool.image_urls.slice();
		log_entry.succ = die_pool.succ;
		log_entry.adv = die_pool.adv;
		log_entry.triumph = die_pool.triumph;
		log_entry.fail = die_pool.fail;
		log_entry.threat = die_pool.threat;
		log_entry.despair = die_pool.despair;
		log_entry.light_side_points = die_pool.light_side_points;
		log_entry.dark_side_points = die_pool.dark_side_points;
		
		var current_log = $scope.remote_logs[$scope.remote_logs.length - 1];
		if (current_log.log_entries) {
			current_log.log_entries.push(log_entry);
			$scope.remote_logs.$save(current_log);
		} else {
			current_log.log_entries = [log_entry];
			$scope.remote_logs.$save(current_log);
		}
	}
	
	$scope.newLog = function() {
		if (!$scope.remote_logs[$scope.remote_logs.length - 1].log_entries) {
			return;
		}
		let new_log = new Log();
		$scope.remote_logs.$add(new Log());
	}
	
	$scope.clearLogs = function() {
		$scope.remote_logs.$ref().remove();
		$scope.remote_logs.$add(new Log());
	}
	
	$scope.getLogs = function(reverse) {
		let logs = $scope.remote_logs.slice();
		if (reverse) {
			return logs.reverse();
		}
		return logs;
	}
	
	$scope.getLogEntries = function(log, reverse) {
		if (!log.log_entries) {
			return [];
		}
		let log_entries = log.log_entries.slice();
		if (reverse) {
			return log_entries.reverse();
		}
		return log_entries;
	}
	
	class Critical {
		constructor(name, severity) {
			this.name = name;
			this.severity = severity;
			this.day_received = 0;
			
			this.description = '';
			this.heal_attempt_made = false;
		}
	}
	
	class Vehicle extends Target {
		constructor(name, model, hull_trauma_threshold, system_strain_threshold, armor, def_fore, def_aft, def_port, def_starboard, weapons, silhouette, speed, handling) {
			super('vehicle');
			
			this.name = name;
			this.model = model;
			this.hull_trauma = 0;
			this.hull_trauma_threshold = hull_trauma_threshold;
			this.system_strain = 0;
			this.system_strain_threshold = system_strain_threshold;
			this.armor = armor;
			this.def_fore = def_fore;
			this.def_aft = def_aft;
			this.def_port = def_port;
			this.def_starboard = def_starboard;
			this.weapons = weapons;
			this.silhouette = silhouette;
			this.speed = speed;
			this.handling = handling;
		}
	}
	
	$scope.getMinionGroupWT = function(minion) {
		return minion.num_in_group * minion.wound_threshold;
	}
	
	$scope.getNumActiveMinions = function(minion) {
		if (minion.wounds - 1 <= 0) {
			return minion.num_in_group;
		}
		let num_dead = Math.min(minion.num_in_group, Math.floor((minion.wounds - 1) / minion.wound_threshold));
		return minion.num_in_group - num_dead;
	}
	
});
</script>

</body>
</html>
